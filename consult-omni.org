
* consult-omni
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./consult-omni.el
:END:
** Header
#+begin_src emacs-lisp
;;; consult-omni.el --- Emacs Omi Search Package -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: ((emacs "28.1") (consult "1.4"))
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:

;;; Code:

#+end_src

** Requirements
#+begin_src emacs-lisp
;;; Requirements
(eval-when-compile
  (require 'json)
  (require 'request nil t)
  (require 'plz nil t))
(require 'consult)
(require 'url)
(require 'url-queue)
#+end_src


** Define Group, Customs, Vars, Etc.
*** group
#+begin_src emacs-lisp
;;; Group
(defgroup consult-omni nil
  "Consulting omni sources"
  :group 'convenience
  :group 'minibuffer
  :group 'consult
  :group 'web
  :group 'search
  :prefix "consult-omni-")
#+end_src

*** customization variables
#+begin_src emacs-lisp
;;; Customization Variables
(defcustom consult-omni-sources-modules-to-load  (list)
  "List of source modules/features to load.

This variable is a list of symbols;
each symbol being a source featue (e.g. consult-omni-brave)"
  :type '(repeat :tag "list of source modules/features to load" symbol))


(defcustom consult-omni-default-browse-function #'browse-url
  "consult-omni default function when selecting a link"
  :type '(choice (function :tag "(Default) Browse URL" browse-url)
                 (function :tag "Custom Function")))


(defcustom consult-omni-alternate-browse-function #'eww-browse-url
  "consult-omni default function when selecting a link"
  :type '(choice (function :tag "(Default) EWW" eww-browse-url)
                 (function :tag "Custom Function")))

(defcustom consult-omni-default-preview-function #'eww-browse-url
  "consult-omni default function when previewing a link"
  :type '(choice (function :tag "(Default) EWW" eww-browse-url)
                 (function :tag "Custom Function")))


(defcustom consult-omni-show-preview nil
  "Should`consult-omni' show previews?
This turns previews on/off globally for all consult-omni sources."
  :type 'boolean)

(defcustom consult-omni-preview-key consult-preview-key
  "Preview key for consult-omni.
This is similar to `consult-preview-key' but explicitly For consult-omni."
  :type '(choice (const :tag "Any Key" Any)
                 (List :tag "Debounced"
                       (const :Debounce)
                       (Float :tag "Seconds" 0.1)
                       (const Any))
                 (const :tag "No Preview" nil)
                 (Key :tag "Key")
                 (repeat :tag "List Of Keys" Key)))


(defcustom consult-omni-default-format-candidate #'consult-omni--highlight-format-candidate
  "consult-omni default function when selecting a link"
  :type '(choice (function :tag "(Default) Adds Metadata and Highlights Query" #'consult-omni--highlight-format-candidate)
                 (function :tag "Simple and Fast Foramting (No Metadata)" #'consult-omni--simple-format-candidate)
                 (function :tag "Custom Function")))


(defcustom consult-omni-default-count 5
  "Number Of search results to retrieve."
  :type 'integer)

(defcustom consult-omni-default-page 0
  "Offset of search results to retrieve.
If this is set to N, the first N “pages”
(or other first N entities, items for example,
depending on the source search capabilities)
of the search results are omitted and the rest are shown."
  :type 'integer)

(defcustom consult-omni-default-timeout 30
  "Default timeout in seconds for synchronous requests."
  :type 'integer)

(defcustom consult-omni-url-use-queue nil
"Use `url-queue-retrieve'?"
:type 'boolean)

(defcustom consult-omni-url-queue-parallel-processes 15
  "The number of concurrent url-queue-retrieve processes."
  :type 'integer)

(defcustom consult-omni-url-queue-timeout 120
  "How long to let a job live once it's started (in seconds)."
  :type '(integer :tag "Timeout in seconds"))

(defcustom consult-omni-log-buffer-name " *consult-omni-log*"
"String for consult-omni-log buffer name"
:type 'string)

(defcustom consult-omni-log-level nil
  "How to make logs for consult-omni requests?
This can be set to nil, 'info or 'debug

nil: Does not log anything

info: Logs URLs and http response header.
Messages erros occuring in colelcting items.

debug: Logs URLs and the entire http response.
Messages erros occuring in colelcting items.

When non-nil, information is logged to `consult-omni-log-buffer-name'."
  :type '(choice
          (const :tag "No Logging" nil)
          (const :tag "Just HTTP Header" info)
          (const :tag "Full Response" debug)))

(defcustom consult-omni-group-by :source
  "What field to use to group the results in the minibuffer?

By default it is set to :source. but can be any of:

  nil       Do not group
  :title    group by candidate's string
  :url      group by URL
  :domain   group by the domain of the URL
  :source   group by source name
  symbol    group by another property of the candidate
 "
  :type '(radio (const :tag "URL path" :url)
                (const :tag "Domain of URL path":domain)
                (const :tag "Name of the search engine or source" :source)
                (const :tag "Custom other field (constant)" :any)
                (const :tag "Do not group" nil)))


(defcustom consult-omni-multi-sources nil
  "List of sources used by `consult-omni-multi'.

This variable is a list of strings or symbols;
 - strings can be name of a source, a key from `consult-omni-sources-alist',
which can be made with the convinient macro `consult-omni-define-source'
or by using `consult-omni--make-source-from-consult-source'.
 - symbols can be other consult sources
(see `consult-buffer-sources' for example.)"
  :type '(choice (repeat :tag "list of source names" string)))


(defcustom consult-omni-highlight-matches t
  "Should `consult-omni' highlight search queries in the minibuffer?"
  :type 'boolean)


(defcustom consult-omni-default-interactive-command #'consult-omni-multi
  "Which command should `consult-omni' call?"
  :type '(choice (function :tag "(Default) multi-source dynamic search"  consult-omni-multi)
                 (function :tag "multi-source static search" consult-omni-multi-static)
                 (function :tag "Other custom interactive command")))


(defcustom consult-omni-http-retrieve-backend 'url
  "Which backend should `consult-omni' use for http requests?"
  :type   '(choice
          (const :tag "(Default) Built-in Emacs's url-retrive" 'url)
          (const :tag "`emacs-request' backend" 'request)
          (const :tag "`plz' backend" 'plz)))

(defcustom consult-omni-default-autosuggest-command nil
  "Which command should `consult-omni' use for auto suggestion on search input?"
  :type '(choice (cons :tag "(Default) no autosuggestion" nil)
          (function :tag "Brave autosuggestion (i.e. `consult-omni-brave-autosuggest')" consult-omni-brave-autosuggest)
                 (function :tag "Google autosuggestion (i.e. `consult-omni-dynamic-google-autosuggest')" consult-omni-dynamic-google-autosuggest)
                 (function :tag "Other custom interactive command")))

(defcustom consult-omni-dynamic-input-debounce consult-async-input-debounce
  "Input debounce for dynamic commands.

The dynamic collection process is started only when
there has not been new input for consult-omni-dynamic-input-debounce seconds.
This is similarto `consult-async-input-debounce' but
specifically for consult-omni dynamic commands.

By default inherits from `consult-async-input-debounce'."
  :type '(float :tag "delay in seconds"))


(defcustom consult-omni-dynamic-input-throttle consult-async-input-throttle
  "Input throttle for dynamic commands.

The dynamic collection process is started only every
`consult-omni-dynamic-input-throttle' seconds. this is similar
to `consult-async-input-throttle' but specifically for
consult-omni dynamic commands.

By default inherits from `consult-async-input-throttle'."
  :type '(float :tag "delay in seconds"))

(defcustom consult-omni-dynamic-refresh-delay consult-async-refresh-delay
  "refreshing delay of the completion ui for dynamic commands.

The completion UI is only updated every
`consult-omni-dynamic-refresh-delay' seconds.
This is similar to `consult-async-refresh-delay' but specifically
for consult-omni dynamic commands.

By default inherits from `consult-async-refresh-delay'. "
  :type '(float :tag "delay in seconds"))


#+end_src

*** other variables
**** categories
#+begin_src emacs-lisp
;;; Other Variables

(defvar consult-omni-sources--all-modules-list (list)
  "List of all source modules.")

(defvar consult-omni-category 'consult-omni
  "Category symbol for the consult-omni seach")

(defvar consult-omni-scholar-category 'consult-omni-scholar
  "Category symbol for scholar search")

(defvar consult-omni-apps-category 'consult-omni-apps
  "Category symbol for app launcher")

(defvar consult-omni-calc-category 'consult-omni-calc
  "Category symbol for calculators")

(defvar consult-omni-video-category 'consult-omni-video
  "Category symbol for video search")

#+end_src

**** history variables
#+begin_src emacs-lisp
(defvar consult-omni--selection-history (list)
  "History variable that keeps selected items.")

(defvar consult-omni--search-history (list)
  "History variable that keeps search terms.")

(defvar consult-omni--calc-select-history (list)
  "History variable that keeps selected calculator result.")

(defvar consult-omni--apps-select-history (list)
  "History variable that keeps list of launched selected.")
#+end_src
**** others
#+begin_src emacs-lisp

(defvar consult-omni-sources-alist (list)
  "Alist of all sources.

This is an alist mapping source names to source property lists.
This alist is used to define how to process data form
a source (e.g. format data) or find what commands to run on
selecting candidates from a source, etc.

You can use the convinient macro `consult-omni-define-source'
or the command `consult-omni--make-source-from-consult-source'
to add to this alist.")

(defvar consult-omni--hidden-buffers-list (list)
  "List of currently open hidden buffers")

(defvar consult-omni--override-group-by nil
"Override grouping in `consult-group' based on user input.

This is used in dynamic collection to change grouping.")

(defconst consult-omni-http-end-of-headers-regexp
  (rx (or "\r\n\r\n" "\n\n"))
  "Regular expression matching the end of HTTP headers.")

(defvar consult-omni-async-processes (list)
  "List of processes for async candidates colleciton")

(defvar consult-omni-dynamic-timers (list)
  "List of timers for dynamic candidates colleciton")

(defvar consult-omni--async-log-buffer " *consult-omni--async-log*"
 "name of buffer for logging async processes info")


#+end_src

*** define faces
#+begin_src emacs-lisp
;;; Faces

(defface consult-omni-default-face
  `((t :inherit 'default))
"Default face used for listing items in minibuffer.")

(defface consult-omni-prompt-face
  `((t :inherit 'font-lock-variable-use-face))
"The face used for prompts in minibuffer.")

(defface consult-omni-engine-title-face
  `((t :inherit 'font-lock-variable-use-face))
"The face for search engine source types in minibuffer.")

(defface consult-omni-ai-title-face
  `((t :inherit 'font-lock-operator-face))
"The face for AI assistant source types in minibuffer.")

(defface consult-omni-files-title-face
  `((t :inherit 'font-lock-number-face))
"The face for file source types in minibuffer.")

(defface consult-omni-notes-title-face
  `((t :inherit 'font-lock-warning-face))
"The face for notes source types in minibuffer.")

(defface consult-omni-scholar-title-face
  `((t :inherit 'font-lock-function-call-face))
"The face for academic literature source types in minibuffer.")

(defface consult-omni-source-type-face
  `((t :inherit 'font-lock-comment-face))
"The face for source annotation in minibuffer.")

(defface consult-omni-date-face
  `((t :inherit 'font-lock-preprocessor-face))
"The face for date annotation in minibuffer.")

(defface consult-omni-domain-face
  `((t :inherit 'font-lock-string-face))
"The face for domain annotation in minibuffer.")

(defface consult-omni-path-face
  `((t :inherit 'font-lock-warning-face))
"The face for path annotation in minibuffer.")

(defface consult-omni-snippet-face
  `((t :inherit 'font-lock-doc-face))
"The face for source annotation in minibuffer.")

(defface consult-omni-keyword-face
  `((t :inherit 'font-lock-keyword-face))
"The face for keyword annotation in minibuffer.")

(defface consult-omni-comment-face
  `((t :inherit 'font-lock-comment-face))
"The face for source annotation in minibuffer.")

(defface consult-omni-highlight-match-face
  `((t :inherit 'consult-highlight-match))
  "Highlight match face for `consult-omni'.")

(defface consult-omni-preview-match-face
  `((t :inherit 'consult-preview-match))
  "Preview match face in `consult-omni' preview buffers.")
#+end_src
** Define Backend Functions
*** general utility
**** properties to plist
#+begin_src emacs-lisp
;;; Bakcend Functions

(defun consult-omni-properties-to-plist (string &optional ignore-keys)
"Returns a plist of the text properties of STRING.

Ommits keys in IGNORE-KEYs."
(let ((properties (text-properties-at 0 string))
      (pl nil))
  (cl-loop for k in properties
           when (keywordp k)
           collect (unless (member k ignore-keys) (push (list k (plist-get properties k)) pl)))
  (apply #'append pl)))
#+end_src
**** propertize with plist
#+begin_src emacs-lisp
(defun consult-omni-propertize-by-plist (item props)
"Propertizes ITEM by PROPS plist"
  (apply #'propertize item props))
#+end_src

**** formatting strings
***** fix string length
****** set string width
#+begin_src emacs-lisp

(defun consult-omni--set-string-width (string width &optional truncate-pos add-pos)
  "Sets the STRING width to a fixed value, WIDTH.

If the STRING is longer than WIDTH, it truncates the STRING
 and adds ellipsis, \"...\". if the STRING is shorter,
it adds whitespace to the STRING.
If TRUNCATE-POS is non-nil, it truncates from position TRUNCATE-POS in the STRING
If ADD-POS is non-nil, it adds whitespace to psition ADD-POS in the STRING.
"
  (let* ((string (format "%s" string))
         (w (length string)))
    (when (< w width)
      (if (and add-pos (< add-pos w))
          (setq string (format "%s%s%s" (substring string 0 add-pos) (consult-omni-propertize-by-plist (make-string (- width w) ?\s) (text-properties-at add-pos string)) (substring string add-pos)))
        (setq string (format "%s%s" (substring string) (make-string (- width w) ?\s)))))
    (when (> w width)
      (if (and truncate-pos (< truncate-pos (- width 3)) (>= truncate-pos 0))
          (setq string (format "%s%s%s" (substring string 0 truncate-pos) (propertize (substring string truncate-pos (+ truncate-pos 3)) 'display "...") (substring string (- 0 (- width truncate-pos 3)))))
        (setq string (format "%s%s"
                             (substring string 0 (- width 3))
                             (propertize  (substring string (- width 3) width) 'display "...")
                             (propertize (substring string width) 'invisible t)))))
    string))
#+end_src
****** justify left
#+begin_src emacs-lisp

(defun consult-omni--justify-left (string prefix maxwidth)
  "Sets the width of STRING+PREFIX justified from left.
It uses `consult-omni--set-string-width' and sets the width
 of the concatenate of STRING+PREFIX
(e.g. `(concat PREFIX STRING)`) within MAXWIDTH.
This can be used for aligning marginalia info in minibuffer."
  (let ((s (length string))
        (w (length prefix)))
    (if (> maxwidth w)
    (consult-omni--set-string-width string (- maxwidth w) 0)
    string
          )
    ))

#+end_src
***** shorten url
#+begin_src emacs-lisp
(defun consult-omni--set-url-width (domain path width)
"It sets the length of DOMAIN+PATH to fit within WIDTH.
"
  (when (stringp domain)
    (let* ((path-width (and (stringp path) (length path)))
           (path-target-width (- width (length domain))))
        (cond
         ((<= path-target-width 0)
          (consult-omni--set-string-width domain width))
         ((integerp path-width)
          (concat domain (consult-omni--set-string-width path path-target-width (floor (/ path-target-width 2)))))
         (t
          (consult-omni--set-string-width (concat domain path) width))))))

#+end_src
***** highlight match with text-properties
#+begin_src emacs-lisp

(defun consult-omni--highlight-match (regexp str ignore-case)
  "Highlights REGEXP in STR.

If a regular expression contains capturing groups,
 only these are highlighted.
If no capturing groups are used, highlight the whole match.
Case is ignored, if ignore-case is non-nil.
(This is adapted from `consult--highlight-regexps'.)"
  (let ((i 0))
    (while (and (let ((case-fold-search ignore-case))
                  (string-match regexp str i))
                (> (match-end 0) i))
      (let ((m (match-data)))
        (setq i (cadr m)
              m (or (cddr m) m))
        (while m
          (when (car m)
            (add-face-text-property (car m) (cadr m)
                                     'consult-omni-highlight-match-face nil str)
            )
          (setq m (cddr m))))))
  str)
#+end_src
***** highlight match with overlay
#+begin_src emacs-lisp

(defun consult-omni--overlay-match (match-str buffer ignore-case)
  "Highlights MATCH-STR in BUFFER using an overlay.
If IGNORE-CASE is non-nil, it uses case-insensitive match.

This is provided for convinience,
if needed in formating candidates or preview buffers."
(with-current-buffer (or (get-buffer buffer) (current-buffer))
  (remove-overlays (point-min) (point-max) 'consult-omni-overlay t)
  (goto-char (point-min))
  (let ((case-fold-search ignore-case)
        (consult-omni-overlays (list)))
    (while (search-forward match-str nil t)
      (when-let* ((m (match-data))
                  (beg (car m))
                  (end (cadr m))
                  (overlay (make-overlay beg end))
                  )
        (overlay-put overlay 'consult-omni-overlay t)
        (overlay-put overlay 'face 'consult-omni-highlight-match-face)
        )))))

(defun consult-omni-overlays-toggle (&optional buffer)
  "Toggles overlay highlights in consult-omni view/preview buffers."
(interactive)
(let ((buffer (or buffer (current-buffer))))
(with-current-buffer buffer
  (dolist (o (overlays-in (point-min) (point-max)))
    (when (overlay-get o 'consult-omni-overlay)
      (if (and (overlay-get o 'face) (eq (overlay-get o 'face) 'consult-omni-highlight-match-face))
          (overlay-put o 'face nil)
         (overlay-put o 'face 'consult-omni-highlight-match-face))
      )
))))
#+end_src
***** hunman-readable numbers
#+begin_src emacs-lisp
(defun consult-omni--numbers-human-readable (number &optional unit separator base prefixes)
  "Convert number to a human-redable string.

SEPARATOR is a string placed between unmber and unit
UNIT is a string used as unit
BASE is the number base used to derive prefix
PREFIXES is a list of chars for each magnitude
(e.g. '(“” “K” “M” “G” ...) for none, kilo, mega, giga, ...

adapted from `file-size-human-readable'.
"
  (let* ((power (if (and base (numberp base)) (float base) 1000.0))
	(prefixes (or prefixes '("" "k" "M" "G" "T" "P" "E" "Z" "Y" "R" "Q")))
        (number (pcase number
                 ((pred numberp)
                  number)
                 ((pred stringp)
                  (string-to-number number))
                 (_ 0))))

    (while (and (>= number power) (cdr prefixes))
      (setq number (/ number power)
	    prefixes (cdr prefixes)))
    (let* ((prefix (car-safe prefixes)))
      (format (if (and (< number 10)
                       (>= (mod number 1.0) 0.05)
                       (< (mod number 1.0) 0.95))
                  "%.1f%s%s%s"
	        "%.0f%s%s%s")
	      number
              prefix
              (or separator " ")
              unit))
    ))
#+end_src

**** make url with params
#+begin_src emacs-lisp

(defun consult-omni--make-url-string (url params &optional ignore-keys)
"Adds key value pairs in PARAMS to URL as “&key=val”.

PARMAS should be an alist with keys and values to add to the URL.
Does not add keys for the key in IGNORE-KEYS list."

  (let* ((url (if (equal (substring-no-properties url -1 nil) "?")
                 url
               (concat url "?")))
         (list (append (list url) (cl-loop for (key . value) in params
                                           collect
                                           (unless (member key ignore-keys)
                                             (format "&%s=%s" key value))))))
  (mapconcat #'identity list)))
#+end_src
**** hashtable-to-plist
#+begin_src emacs-lisp

(defun consult-omni-hashtable-to-plist (hashtable &optional ignore-keys)
"Converts a HASHTABLE to a plist.

Ommits keys in IGNORE-KEYS."

(let ((pl nil))
    (maphash
     (lambda (k v)
       (unless (member k ignore-keys)
         (push (list k v) pl)))
     hashtable)
    (apply #'append pl)))
#+end_src

**** expand function in variable
#+begin_src emacs-lisp

(defun consult-omni-expand-variable-function (var)
"Call the function if VAR is a function"
  (if (functionp var)
                 (funcall var)
    var))
#+end_src
*** http requests
**** backends
***** url retrieve  backend
****** log
#+begin_src emacs-lisp
(defun consult-omni--url-log (string)
  "Logs the response from `consult-omni-url-retrieve-sync'

the log is inserted in the buffer `consult-omni-log-buffer-name'."
   (with-current-buffer (get-buffer-create consult-omni-log-buffer-name)
     (goto-char (point-min))
     (insert "**********************************************\n")
     (goto-char (point-min))
     (insert (format-time-string "%F - %T%n" (current-time)))
     (insert string)
     (insert "\n")
     (goto-char (point-min))
     (insert "\n\n**********************************************\n")))
#+end_src
****** parse http response
#+begin_src emacs-lisp
(defun consult-omni--parse-http-response (&optional buffer)
  "Parse the first header line such as \"HTTP/1.1 200 OK\"."
(with-current-buffer (or buffer (current-buffer))
  (save-excursion
    (goto-char (point-min))
    (when (re-search-forward "\\=[ \t\n]*HTTP/\\(?1:[0-9\\.]+\\) +\\(?2:[0-9]+\\)" url-http-end-of-headers t)
    `(:http-version ,(match-string 1) :code ,(string-to-number (match-string 2)))))))
#+end_src
****** get the response body
#+begin_src emacs-lisp
(defun consult-omni--url-response-body (response-data)
"Extracts the response body from `url-retrieve'."
(plist-get response-data :data))
#+end_src

****** error-handler
#+begin_src emacs-lisp
(defun consult-omni--url-retrieve-error-handler (&rest args)
  "Handles errors for consult-omni-url-retrieve functions."
  (message "consult-omni: url-retrieve got an error: %s" (consult-omni--parse-http-response)))
#+end_src
****** url retrieve
#+begin_src emacs-lisp
(cl-defun consult-omni-url-retrieve (url &rest settings &key (sync 'nil) (type "GET") params headers data parser callback error timeout &allow-other-keys)
  "Retrieves URL with settings.

Passes all the arguments to
`url-retrieve', `url-retrieve-queue' or `url-retrieve-snchronously'.

if SYNC is non-nil, it retrieves URL sunchronously
(see `url-retrieve-synchronously'.)

TYPE is the http request type (e.g. “GET”, “POST”)

PARAMS are parameters added to the base url
using `consult-omni--make-url-string'.

HEADERS are headers passed to headers (e.g. `url-request-extra-headers').

DATA are http request data passed to data (e.g. `url-request-data').

PARSER is a function that is executed in the url-retrieve
response and the results are passed to CALLBACK. It is called wthout any arguments
in the response buffer (i.e. it called like (funcall PARSER))
This is for example suitable for #'json-read.

CALLBACK is the function that is executed when the request is complete.
It takes one argument, PARSED-DATA which is the output of the PARSER above.
(i.e. it is called like (funcall CALLBACK (funcall PARSER)))

ERROR is a function that handles errors. It is called without any arguments
in the response buffer.

TIMEOUT is the time in seconds for timing out synchronous requests.
This is ignored in async requests.

Note that  when `consult-omni-url-use-queue' is set to t, this function uses `url-queue-retrieve' sets url-queue-parallel-processes and url-queue-timeout
to `consult-omni-url-queue-parallel-processes',
and `consult-omni-url-queue-timeout', respectively.
"
  (let* ((url-request-method type)
         (url-request-extra-headers headers)
         (url-request-data data)
         (url-with-params (consult-omni--make-url-string url params))
         (url-debug (if consult-omni-log-level t nil))
         (url-queue-parallel-processes consult-omni-url-queue-parallel-processes)
         (url-queue-timeout consult-omni-url-queue-timeout)
         (retriever (if consult-omni-url-use-queue #'url-queue-retrieve #'url-retrieve))
         (response-data '(:status nil :data nil))
         (buffer (if sync
                     (if timeout
                         (with-timeout
                             (timeout
                              (setf response-data (plist-put response-data :status 'timeout))
                              nil)
                           (url-retrieve-synchronously url-with-params 'silent nil timeout))
                       (url-retrieve-synchronously url-with-params 'silent nil timeout))
                   (funcall retriever url-with-params
                                 (lambda (status &rest args)
                                   (let* ((parsed-data (condition-case nil
                                                     (if parser (funcall parser) (buffer-substring (point-min) (point-max)))
                                                   (error (funcall error)))))
                                     (setf response-data (plist-put response-data :status status))
                                     (when parsed-data
                                       (setf response-data (plist-put response-data :data (funcall callback parsed-data)))))) nil 'silent))))

    (when (and buffer (buffer-live-p buffer))
      (add-to-list 'consult-omni--hidden-buffers-list buffer)
      (if sync
          (with-current-buffer buffer
            (save-excursion
              (goto-char (point-min))
              (let* ((end-of-headers (if (and (bound-and-true-p url-http-end-of-headers)
                                              (number-or-marker-p url-http-end-of-headers))
                                         url-http-end-of-headers
                                       (point-min)))
                     (response (buffer-substring (point-min) (pos-eol)))
                     (header (buffer-substring (point-min) end-of-headers))
                     (body (buffer-substring end-of-headers (point-max))))
                (when consult-omni-log-level
                  (cond
                   ((eq consult-omni-log-level 'info)
                    (consult-omni--url-log (format "URL: %s\nRESPONSE: %s" url response)))
                   ((eq consult-omni-log-level 'debug)
                    (consult-omni--url-log (format "URL: %s\n\nRESPONSE-HEADER:\n%s\n\nRESPONSE-BODY: %s\n" url header body)))))
                (setf response-data (plist-put response-data :status response))
                (delete-region (point-min) (+ end-of-headers 1))
                (goto-char (point-min))
                (if-let* ((parsed-data (condition-case nil
                                     (funcall parser)
                                   (error (funcall error)))))
                    (setf response-data (plist-put response-data :data (funcall callback parsed-data)))))))))
    response-data))
#+end_src
***** request backend
****** error-handler
#+begin_src emacs-lisp
(cl-defun consult-omni--request-error-handler (&rest args &key symbol-status error-thrown &allow-other-keys)
  "Handles errors for request backend.
See `request' for more details."
  (message "consult-omni: <request>  %s - %s" symbol-status error-thrown))
#+end_src
****** consult-omni--request-sync
#+begin_src emacs-lisp

  (cl-defun consult-omni--request-sync (url &rest args &key params headers data parser placeholder error encoding &allow-other-keys)
    "Convinient wrapper for `request'.

Passes all the arguments to request and fetches the
results *synchronously*.

Refer to `request' documents for details."
    (unless (functionp 'request)
      (error "Request backend not available. Either install the package “emacs-request” or change the custom variable `consult-omni-retrieve-backend'"))
    (let (candidates)
      (request
        url
        :sync t
        :params params
        :headers headers
        :parser parser
        :error (or error #'consult-omni--request-error-handler)
        :data data
        :encoding (or encoding 'utf-8)
        :success (cl-function (lambda (&key data &allow-other-keys)
                                (setq candidates data))))

      candidates))
#+end_src
***** plz
****** error-handler
#+begin_src emacs-lisp
(cl-defun consult-omni--plz-error-handler (plz-error &rest args)
  "Handles errors for `plz' backend.
Refer to `plz' documentation for more details."
  (message "consult-omni: <plz> %s" plz-error))
#+end_src
**** universal
***** parse buffer
#+begin_src emacs-lisp
(defun consult-omni--json-parse-buffer ()
"Default json parser used in consult-omni"
(let ((end-of-headers (if (and (bound-and-true-p url-http-end-of-headers)
                               (number-or-marker-p url-http-end-of-headers))
                          url-http-end-of-headers
                        (point-min))))
(goto-char end-of-headers)
(json-parse-buffer :object-type 'hash-table :array-type 'list :false-object :false :null-object :null)))
#+end_src
***** fetch url
#+begin_src emacs-lisp
(cl-defun consult-omni--fetch-url (url backend &rest args &key type params headers data parser callback error encoding timeout sync &allow-other-keys)
  "Retrieves URL with support for different BACKENDs.

This is a wrapper that passes the args to corresponding
BACKEND functions. (i.e. `consult-omni-url-retrieve',
 `request', `plz', ...) See backend functions for details.

if SYNC is non-nil, it retrieves URL sunchronously.

TYPE is the http request type (e.g. “GET”, “POST”)

PARAMS are parameters added to the base url
using `consult-omni--make-url-string'.

HEADERS are headers passed to headers (e.g. `url-request-extra-headers').

DATA are http request data passed to data (e.g. `url-request-data').

PARSER is a function that is executed in the url-retrieve
response and the results are passed to CALLBACK.
See `consult-omni-url-retrieve', `request', or `plz' for more info.

CALLBACK is the function that is executed when the request is complete.
It takes one argument, PARSED-DATA which is the output of the PARSER above.
(i.e. it is called like (funcall CALLBACK (funcall PARSER)))
See `consult-omni-url-retrieve', `request', or `plz' for more info.

ERROR is a function that handles errors. It is called without any arguments
in the response buffer.

ENCODING is the encoding used for the request backend (e.g. 'utf-8)

TIMEOUT is the time in seconds for timing out synchronous requests.
This is ignored in async requests.

"
  (cond
   ((eq backend 'plz)
    (if sync
        (funcall callback (funcall #'plz (or type 'get) (consult-omni--make-url-string url params)
                                   :headers headers
                                   :as parser
                                   :then 'sync
                                   :else (or error #'consult-omni--plz-error-handler)
                                   :timeout (or timeout consult-omni-default-timeout)))
      (funcall #'plz (or type 'get) (consult-omni--make-url-string url params)
               :headers headers
               :as parser
               :then callback
               :else (or error #'consult-omni--plz-error-handler)
               :timeout (or timeout consult-omni-default-timeout))))
   ((eq backend 'url)
    (if sync
        (consult-omni--url-response-body
         (funcall #'consult-omni-url-retrieve url
                  :sync sync
                  :type (or type "GET")
                  :params params
                  :headers headers
                  :parser parser
                  :data data
                  :error (or error #'consult-omni--url-retrieve-error-handler)
                  :callback (or callback #'identity)
                  :timeout (or timeout consult-omni-default-timeout)))
      (funcall #'consult-omni-url-retrieve url
               :sync sync
               :type (or type "GET")
               :params params
               :headers headers
               :parser parser
               :data data
               :error (or error #'consult-omni--url-retrieve-error-handler)
               :callback (or callback #'identity)
               :timeout (or timeout consult-omni-default-timeout))))
   ((eq backend 'request)
    (if sync
        (funcall callback
                 (request-response-data
                  (funcall #'request url
                           :sync sync
                           :params params
                           :headers headers
                           :parser parser
                           :data data
                           :error (or error #'consult-omni--request-error-handler)
                           :encoding (or encoding 'utf-8)
                           :timeout (or timeout consult-omni-default-timeout)
                           )))
      (funcall #'request url
               :params params
               :headers headers
               :parser parser
               :data data
               :error (or error #'consult-omni--request-error-handler)
               :encoding (or encoding 'utf-8)
               :timeout (or timeout consult-omni-default-timeout)
               :complete (cl-function (lambda (&key data &allow-other-keys)
                                        (funcall (or callback #'identity) data)))
               ))
    )))
#+end_src
*** consult-omni backend
**** utilities
***** kill hidden buffer
#+begin_src emacs-lisp
(defun consult-omni--kill-hidden-buffers ()
"Kill all open preview buffers stored in
`consult-gh--preview-buffers-list'.

It asks for confirmation if the buffer is modified
and removes the buffers that are killed from the list."
  (interactive)
  (when consult-omni--hidden-buffers-list
    (mapcar (lambda (buff) (if (and (buffer-live-p buff) (not (get-buffer-process buff)))
                             (kill-buffer buff))) consult-omni--hidden-buffers-list)
    )
  (setq consult-omni--hidden-buffers-list nil)
)
#+end_src

***** kill dead buffers
#+begin_src emacs-lisp
(defun consult-omni--kill-url-dead-buffers ()
"Kill buffers in `url-dead-buffer-list'."
  (interactive)
  (when url-dead-buffer-list
    (mapcar (lambda (buff) (if  (and (buffer-live-p buff) (not (get-buffer-process buff)))
                             (kill-buffer buff))
               ) url-dead-buffer-list)
    )
  (setq url-dead-buffer-list nil)
)
#+end_src

***** log
****** consult-omni-async-log
#+begin_src emacs-lisp
(defun consult-omni--async-log (formatted &rest args)
  "Log FORMATTED ARGS to variable `consult-omni--async-log-buffer'."
  (with-current-buffer (get-buffer-create consult-omni--async-log-buffer)
    (goto-char (point-max))
    (insert (apply #'format formatted args))))
#+end_src


***** get source prop
#+begin_src emacs-lisp
(defun consult-omni--get-source-prop (source prop)
"Get PROP for SOURCE from `consult-omni-sources-alist'."
(plist-get (cdr (assoc source consult-omni-sources-alist)) prop)
)
#+end_src
***** thing at point
#+begin_src emacs-lisp
(defun consult-omni-dynamic--split-thingatpt (thing &optional split-initial)
  "Return THING at point.

If SPLIT-INITIAL is non-nil use `consult--async-split-initial'
to format the string."
  (when-let (str (thing-at-point thing t))
    (if split-initial
        (consult--async-split-initial str)
      str)))

#+end_src
***** read search string
#+begin_src emacs-lisp
(defun consult-omni--read-search-string (&optional initial)
"Read a string from the minibuffer.

This is used to get initial input for static commands, when
`consult-omni-default-autosuggest-command' is nil."
  (consult--read nil
                 :prompt "Search: "
                 :initial initial
                 :category 'consult-omni
                 :history 'consult-omni--search-history
                 :add-history (consult-omni--add-history)
                                        ))
#+end_src
**** format / annotate candidates
***** simple no highlighting and metadata
#+begin_src emacs-lisp

(cl-defun consult-omni--simple-format-candidate (&rest args &key source query url search-url title snippet &allow-other-keys)
  "Returns a simple formatted string for candidates.

SOURCE is the name string of the source for candidate

QUERY is the query string used for searching

URL is a string pointing to url of the candidate

SEARCH-URL is a string pointing to the url for
the search results of QUERY on the SOURCE website

TITLE is the title of the candidate

SNIPPET is a string containing a snippet/description of candidate
"
  (let* ((frame-width-percent (floor (* (frame-width) 0.1)))
         (title-str (consult-omni--set-string-width title (* 5 frame-width-percent))))
         (concat title-str
                      (when source (concat "\t" source)))))
#+end_src

***** with highlighted query and searchable metadata
#+begin_src emacs-lisp
(cl-defun consult-omni--highlight-format-candidate (&rest args &key source query url search-url title snippet face &allow-other-keys)
  "Returns a highlighted formatted string for candidates.

SOURCE is the name string of the source for candidate

QUERY is the query string used for searching

URL is a string pointing to url of the candidate

SEARCH-URL is a string pointing to the url for
the search results of QUERY on the SOURCE website

TITLE is the title of the candidate

SNIPPET is a string containing a snippet/description of candidate

FACE is the face used for the title
"
  (let* ((frame-width-percent (floor (* (frame-width) 0.1)))
         (source (and (stringp source) (propertize source 'face 'consult-omni-source-type-face)))
         (match-str (and (stringp query) (consult--split-escaped query) nil))
         (face (or (consult-omni--get-source-prop source :face) face 'consult-omni-default-face))
         (title-str (propertize title 'face face))
         (title-str (consult-omni--set-string-width title-str (* 4 frame-width-percent)))
         (snippet (and (stringp snippet) (consult-omni--set-string-width snippet (* 3 frame-width-percent))))
         (snippet (and (stringp snippet) (propertize snippet 'face 'consult-omni-snippet-face)))
         (urlobj (and url (url-generic-parse-url url)))
         (domain (and (url-p urlobj) (url-domain urlobj)))
         (domain (and (stringp domain) (propertize domain 'face 'consult-omni-domain-face)))
         (path (and (url-p urlobj) (url-filename urlobj)))
         (path (and (stringp path) (propertize path 'face 'consult-omni-path-face)))
         (url-str (consult-omni--set-url-width domain path (* frame-width-percent 2)))
         (str (concat title-str
                      (when url-str (concat "\s" url-str))
                      (when snippet (concat "\s\s" snippet))
                      (when source (concat "\t" source)))))
    (if consult-omni-highlight-matches
        (cond
         ((listp match-str)
          (mapcar (lambda (match) (setq str (consult-omni--highlight-match match str t))) match-str))
         ((stringp match-str)
          (setq str (consult-omni--highlight-match match-str str t)))))
    str))
#+end_src

**** group candidates based on a keyword

#+begin_src emacs-lisp

(defun consult-omni--group-function (sources cand transform &optional group-by)
  "Group candidates by GROUP-BY keyword.

This is passed as GROUP to `consult--read' on candidates
and is used to define the grouping for CAND. "
  (if transform (substring cand)
    (let* ((group-by (or consult-omni--override-group-by group-by consult-omni-group-by))
           (group-by (if (not (keywordp group-by)) (intern (concat ":" (format "%s" group-by))) group-by)))
      (cond
       ((equal group-by :domain)
        (if-let* ((url (get-text-property 0 :url cand))
                  (urlobj (if url (url-generic-parse-url url) nil))
                  (domain (if (url-p urlobj) (url-domain urlobj))))
            domain
          nil))
       ((member group-by '(:nil :none :no :not))
        nil)
       (group-by
        (if-let ((group (get-text-property 0 group-by cand)))
            (format "%s" group)
          "N/A"))
       (t
        (if-let* ((source (plist-get (consult--multi-source sources cand) :name)))
            source
          nil)))
      )))
#+end_src


**** add-history
#+begin_src emacs-lisp
(defun consult-omni--add-history (&rest args)
  "Makes a list for future history based on at-point items."
  (delq nil
        (cl-remove-duplicates
         (append (mapcar (lambda (thing) (consult-omni-dynamic--split-thingatpt thing nil))
                         (list 'number 'word 'sexp 'symbol 'url 'filename 'sentence 'line)) (list isearch-string)))))
#+end_src
**** lookup function
#+begin_src emacs-lisp
(defun consult-omni--lookup-function ()
  "Lookup function for `consult-omni' minibuffer candidates.

This is passed as LOOKUP to `consult--read' on candidates
and is used to format the output when a candidate is selected."
  (lambda (sel cands &rest args)
    (let* ((info (or (car (member sel cands)) ""))
           (title (get-text-property 0 :title info))
           (url (get-text-property 0 :url info))
           )
      (consult-omni-propertize-by-plist (or title url "nil") (or (text-properties-at 0 info) (list)))
      )))
#+end_src
**** preview
#+begin_src emacs-lisp
(defun consult-omni--default-url-preview (cand)
  "Default function to use for previewing CAND."
  (when (listp cand) (setq cand (car-safe cand)))
  (when-let* ((url (get-text-property 0 :url cand))
              (buff (funcall consult-omni-default-preview-function url)))
    (funcall (consult--buffer-preview) 'preview buff)
    ))
#+end_src
**** state
***** make state
#+begin_src emacs-lisp

(cl-defun consult-omni--make-state-function (&rest args &key setup preview exit return &allow-other-keys)
  "Convinient wrapper for `consult-omni' to make custom state functions.

This can be passed as STATE to `consult--read' on candidates and is
used to define actions when setting up, previewing or selecting a
candidate. Refer to `consult--read' documentation for more details."
  (lambda (action cand &rest args)
    (if cand
        (pcase action
          ('setup
           (funcall setup cand))
          ('preview
           (funcall preview cand))
          ('exit
           (funcall exit cand))
          ('return
           (funcall return cand))
          )))
  )

#+end_src
***** dynamic state function
#+begin_src emacs-lisp
(defun consult-omni--dynamic-state-function ()
  "State function for `consult-omni' minibuffer candidates.

This is passed as STATE to `consult--read' on candidates and is used
to define actions that happen when a candidate is previewed or
selected.
The 'setup, 'preview, 'return and 'exit actions
are all retrieved from `consult-omni-sources-alist'."
  (let ((buffer-preview (consult--buffer-preview)))
    (lambda (action cand &rest args)
      (if cand
          (let* ((source (get-text-property 0 :source cand))
                 (state (consult-omni--get-source-prop source :state))
                 (setup (consult-omni--get-source-prop source :on-setup))
                 (preview (consult-omni--get-source-prop source :on-preview))
                 (return (consult-omni--get-source-prop source :on-return))
                 (exit (consult-omni--get-source-prop source :on-exit)))
            (if state
                (funcall state action cand args)
              (pcase action
                ('setup
                 (if setup (funcall setup cand)))
                ('preview
                 (if preview (funcall preview cand) (consult-omni--default-url-preview cand)))
                ('return
                 (if return (funcall return cand) cand))
                ('exit
                 (unless consult-omni-log-level
                   (consult-omni--kill-hidden-buffers)
                   (consult-omni--kill-url-dead-buffers)
                   )
                 (funcall buffer-preview 'exit cand)
                 (if exit (funcall exit cand))))
              ))))))
#+end_src
**** callback
#+begin_src emacs-lisp
(defun consult-omni--default-callback (cand)
  "Default CALLBACK for CAND.

The CALLBACK is called when a CAND is selected.
When making consult-omni sources, if a CALLBACK is not provided, this
CALLBACK is used as a fall back."
  (when (listp cand) (setq cand (car-safe cand)))
  (if-let ((url (get-text-property 0 :url cand)))
      (funcall consult-omni-default-browse-function url)))
#+end_src
**** new
#+begin_src emacs-lisp
(defun consult-omni--default-new (cand)
"Default NEW function for a non-existing CAND.

When making consult-omni sources, if a NEW is not provided, this
function is used as a fall back.

NEW is used called when a selected candidate
is a new candiate not existing in the minibuffer completion list.
"
(when (listp cand) (setq cand (car-safe cand)))
(or (and (stringp cand) (string-trim cand (consult--async-split-initial nil)))
    cand))
#+end_src
**** dynamic/async collection
***** get key value pair from opt
#+begin_src emacs-lisp
(defun consult-omni--extract-opt-pair (opt opts ignore-opts)
  "Extracts a pair of (OPT . value) from a list OPTS.

values is the next element after OPT in OPTS.
Excludes keys in IGNORE_OPTS.
This is useful for example to extract key value pairs
from command-line options in alist of strings"
  (unless (member opt ignore-opts)
    (let* ((key (cond
             ((string-match-p "-.*$" opt)
             (intern (concat ":" (replace-regexp-in-string "--" "" opt))))
             ((string-match-p ":.*$" opt)
              (intern opt))
             (t nil)))
           (val (or (cadr (member opt opts)) "nil"))
           )
    (when key
      (cons key val)))))

#+end_src
***** split-command
#+begin_src emacs-lisp
(defun consult-omni--split-command (input &rest args)
  "Return command argument and options list given INPUT str.

It constructs built-in arguments for count and page, ..., and
it also sets `consult-omni--override-group-by' if and argument
for grouping is provided in options.
"
  (pcase-let* ((`(,query . ,opts) (consult--command-split input))
               (args (if (member (flatten-list args) (list nil (list nil))) nil args)))
    (if (and opts (listp opts) (> (length opts) 0))
        (progn
          (setq opts (cl-substitute ":count" ":n" opts :test 'equal))
          (setq opts (cl-substitute ":count" "-n" opts :test 'equal))
          (setq opts (cl-substitute ":page" ":p" opts :test 'equal))
          (setq opts (cl-substitute ":page" "-p" opts :test 'equal))
          (setq opts (cl-substitute ":group" ":g" opts :test 'equal))
          (setq opts (cl-substitute ":group" "-g" opts :test 'equal))
          (if (member ":group" opts)
              (setq consult-omni--override-group-by (cadr (member ":group" opts)))
            (setq consult-omni--override-group-by nil))
          (cl-loop for opt in opts
                   do
                   (pcase-let* ((`(,key . ,val) (consult-omni--extract-opt-pair opt opts (list ":group"))))
                     (when key
                       (setq args (append args (list key val)))))))
      (setq consult-omni--override-group-by nil))
    (list (or query input) args)
    ))
#+end_src
***** filter by minibuffer content
#+begin_src emacs-lisp
(defun consult-omni--match-minibuffer-content-p (cand)
  "Filter minibuffer candidates by minibuffer content.

Uses regexp to only keep candidates that match
the current content of the minibuffer. This is useful
when using a sync source in an async/dynamic
fashion as the input in the minibuffer is used to filter
the candidates for the sync source
"
  (let* ((win (active-minibuffer-window))
        (buffer (window-buffer win))
        (split-char (plist-get (consult--async-split-style) :initial)))
  (with-current-buffer buffer
    (if (minibuffer-window-active-p win)
        (string-match (concat ".*" (string-trim (car-safe (consult-omni--split-command (minibuffer-contents-no-properties))) split-char "\n") ".*") (substring-no-properties cand))))))
#+end_src
***** async builders
#+begin_src emacs-lisp
(defun consult-omni--async-builder (input command-args)
  "Build command line from INPUT.

COMMAND-ARGS are commandline args (e.g. “grep”)"
  (pcase-let ((`(,arg . ,opts) (consult--command-split input)))
    (unless (string-blank-p arg)
      (cons (append (consult--build-args command-args)
                    (consult--split-escaped arg) opts)
            (cdr (consult--default-regexp-compiler input 'basic t))))))

#+end_src
**** consult-omni-multi-static
***** static collect synchronous candidates
#+begin_src emacs-lisp
(defun consult-omni--multi-static-sync-candidates (source idx input &rest args)
  "Synchronously collects and returns candidates of a “sync” SOURCE

This returns the candidates with properties suitable
for use in a static (not dynamically updated) multi-source command
"
  (let* ((name (plist-get source :name))
         (face (and (plist-member source :face) `(face ,(plist-get source :face))))
         (cat (plist-get source :category))
         (transform (consult-omni--get-source-prop name :transform))
         (fun (plist-get source :items))
         (items))
    (when (functionp fun)
      (cond
       ((and (integerp (cdr (func-arity fun))) (< (cdr (func-arity fun)) 1))
        (setq items (funcall fun)))
       (t
        (setq items (funcall fun input args)))))
    (when (and items transform)
      (setq items (funcall transform items action)))
    (and items (consult-omni--multi-propertize items cat idx face))
    ))
#+end_src

***** static collect dynamic candidates
#+begin_src emacs-lisp
(defun consult-omni--multi-static-dynamic-candidates (source idx input &rest args)
  "Synchronously collects and returns candidates of a “dyanmic” SOURCE

This returns the candidates with properties suitable
for use in a static (not dynamically updated) multi-source command
"
  (let* ((name (plist-get source :name))
         (face (and (plist-member source :face) `(face ,(plist-get source :face))))
         (cat (plist-get source :category))
         (name (plist-get source :name))
         (transform (consult-omni--get-source-prop name :transform))
         (fun (plist-get source :items))
         (items)
         (current))
    (when (functionp fun)
      (funcall fun input
               :callback (lambda (response-items)
                           (if response-items
                               (progn
                                 (when transform (setq response-items (funcall transform response-items action)))
                                 (setq current
                                       (and response-items (consult-omni--multi-propertize
                                                            response-items cat idx face))))
                             (setq current t)))
               args)
      (let ((count 0)
            (max consult-omni-default-timeout)
            (step 0.05))
        (while (and (< count max) (not current))
          (+ count step)
          (if (>= count max)
              (message "consult-omni: Hmmm! %s took longer than expected." name)
            (sit-for step))))
      current)))
#+end_src



***** static collect async candidates
#+begin_src emacs-lisp
(defun consult-omni--multi-static-async-candidates (source idx input &rest args)
"Synchronously collects and returns candidates of an “async” SOURCE

This returns the candidates with properties suitable
for use in a static (not dynamically updated) multi-source command
"
  (let* ((name (plist-get source :name))
         (builder (plist-get source :items))
         (transform (consult-omni--get-source-prop name :transform))
         (filter (consult-omni--get-source-prop name :filter))
         (props (seq-drop-while (lambda (x) (not (keywordp x))) args))
         (proc)
         (proc-buf)
         (face (and (plist-member source :face) `(face ,(plist-get source :face))))
         (consult-omni--async-log-buffer (concat " *consult-omni-async-log--" name "*"))
         (cat (plist-get source :category))
         (query (car (consult-omni--split-command input)))
         (cmd (funcall builder input))
         (items))
    (unless (stringp (car cmd))
        (setq cmd (car cmd)))
      (when cmd
        (let* ((lines)
               (process-adaptive-read-buffering nil)
               (out (with-temp-buffer
                          (set-buffer-file-coding-system 'cp1047)
                          (list (apply 'call-process (car cmd) nil (current-buffer) nil (cdr cmd))
                                (replace-regexp-in-string "" "\n"
                                                   (buffer-string))))))

          (if (eq (car out) 0)
            (progn
              (setq lines (mapcar (lambda (line) (propertize line :source name :title line :query query)) (split-string (cadr out) "[\r\n]+" t)))
              (when (and lines filter (functionp filter)) (setq lines (funcall filter lines query)))
              (when (and lines transform (functionp transform)) (setq lines (funcall transform lines query)))
              )
            (message "process %s returned error with code %s and message %s" name (car out) (cdr out)))

          (consult-omni--multi-propertize lines cat idx face)
))))

#+end_src

***** multi-candidates-static
#+begin_src emacs-lisp
(defun consult-omni--multi-candidates-static (sources &optional input &rest args)
  "Return candidates from SOURCES for `consult-omni--multi-static'."
  (let* ((candidates)
         (idx 0))
    (seq-doseq (src sources)
      (let* ((name (and (plist-member src :name) (plist-get src :name)))
             (face (and (plist-member src :face) `(face ,(plist-get src :face))))
             (cat (plist-get src :category))
             (items (plist-get src :items))
             (narrow (plist-get src :narrow))
             (async-type (and name (consult-omni--get-source-prop name :type)))
             (narrow-type (or (car-safe narrow) narrow -1))
             (err (if consult-omni-log-level 'err nil))
             )
        (when (or (eq consult--narrow narrow-type)
                  (not (or consult--narrow (plist-get src :hidden))))
          (condition-case err
              (progn
                (when (functionp items)
                  (cond
                   (; sync source, append candidates right away
                    (eq async-type 'sync)
                    (push (consult-omni--multi-static-sync-candidates src idx input args) candidates)
                    )
                   (; dynamic source, append candidates and wait for it to populate
                    (eq async-type 'dynamic)
                    (push (consult-omni--multi-static-dynamic-candidates src idx input args) candidates)
                    )
                   (; async source, append candidates from process
                    (eq async-type 'async)
                    (push (consult-omni--multi-static-async-candidates src idx input args) candidates)
                    )

                   (t
                    (message "source %s needs a :type keyword. See the documentation for `consult-omni-define-source'." name)
                    ))))
            ('wrong-type-argument nil)
            ('error
             (message (if consult-omni-log-level
                          (format "error in calling :items of %s source - %s" name (error-message-string err))
                        (format "error in calling :items of %s source" name)))
             nil)
            )))
      (cl-incf idx))
   (apply #'append candidates)))
#+end_src


***** consult-omni--multi-static
#+begin_src emacs-lisp
(defun consult-omni--multi-static (sources input args &rest options)
  "Reads candidates from SOURCES with static interface

This is similar to `consult--multi'
but accepts async/dynamic sources as well.
See `consult--multi' for more info.

OPTIONS are similar to options in `consult--multi'.

ARGS are sent as additional args to each source
collection function.
"
(let* ((sources (consult--multi-enabled-sources sources))
         (candidates (consult--slow-operation "Give me a few seconds. The internet is a big mess!" (consult-omni--multi-candidates-static sources input args)))
         (selected
          (apply #'consult--read
                 candidates
                 (append
                  options
                  (list
                   :sort        nil
                   :history     'consult-omni--selection-history
                   :category    'multi-category
                   :predicate   (apply-partially #'consult-omni--multi-predicate sources)
                   :annotate    (apply-partially #'consult-omni--multi-annotate sources)
                   :group       (apply-partially #'consult-omni--multi-group sources)
                   :lookup      (apply-partially #'consult-omni--multi-lookup sources)
                   :preview-key (consult--multi-preview-key sources)
                   :narrow      (consult--multi-narrow sources)
                   :state       (consult--multi-state sources))))))
    (if (plist-member (cdr selected) :match)
        (when-let (fun (plist-get (cdr selected) :new))
          (funcall fun (car selected))
          (plist-put (cdr selected) :match 'new))
      (when-let (fun (plist-get (cdr selected) :action))
        (funcall fun (car selected)))
      (setq selected `(,(car selected) :match t ,@(cdr selected))))
    selected))
#+end_src

**** consult-omni-multi-dynamic
***** multi-lookup
#+begin_src emacs-lisp
(defun consult-omni--multi-lookup (sources selected candidates _input narrow &rest _)
  "Lookup SELECTED in CANDIDATES given SOURCES, with potential NARROW.

Adopted from `consult--multi-lookup'"
  (if (or (string-blank-p selected)
          (not (consult--tofu-p (aref selected (1- (length selected))))))
      ;; Non-existing candidate without Tofu or default submitted (empty string)
      (let* ((src (cond
                   (narrow (seq-find (lambda (src)
                                       (let ((n (plist-get src :narrow)))
                                         (eq (or (car-safe n) n -1) narrow)))
                                     sources))
                   ((seq-find (lambda (src) (plist-get src :default)) sources))
                   ((seq-find (lambda (src) (not (plist-get src :hidden))) sources))
                   ((aref sources 0))))
             (idx (seq-position sources src))
             (def (and (string-blank-p selected) ;; default candidate
                       (seq-find (lambda (cand) (eq idx (consult--tofu-get cand))) candidates))))
        (if def
            (cons (cdr (get-text-property 0 'multi-category def)) src)
          `(,selected :match nil ,@src)))
    (let* ((found (member selected candidates))
           (info (if found (or (car found) "") ""))
           (title (get-text-property 0 :title info))
           (url (get-text-property 0 :url info))
           )
      (if found
        ;; Existing candidate submitted
        (cons (apply #'propertize (or title url "nil") (or (text-properties-at 0 info) (list)))
              (consult--multi-source sources selected))
      ;; Non-existing Tofu'ed candidate submitted, e.g., via Embark
      `(,(substring selected 0 -1) :match nil ,@(consult--multi-source sources selected))))))

#+end_src
***** muli-group
#+begin_src emacs-lisp
(defun consult-omni--multi-group (sources cand &optional transform)
  "Return group string of candidate CAND.

Returns the group string for candidate or transforms it
for all the candidates given SOURCES.

Adopted from `consult--multi-group'"
  (if transform
      cand
    (let* ((fun (and (plist-member (consult--multi-source sources cand) :group)
                     (plist-get (consult--multi-source sources cand) :group))))
      (cond
       ((functionp fun)
        (let ((argnum (cdr (func-arity fun))))
        (cond
         ((or (stringp argnum) (and (numberp argnum) (> argnum 2)))
              (funcall fun sources cand transform))
         ((and (numberp argnum) (= argnum 2))
          (funcall fun cand transform))
         ((and (numberp argnum) (= argnum 1))
          (funcall fun cand)))))
       ((stringp fun)
        fun)
       ((eq fun 'nil)
        nil)
       (t
        (plist-get (consult--multi-source sources cand) :name))))))
#+end_src
***** multi-predicate
#+begin_src emacs-lisp
(defun consult-omni--multi-predicate (sources cand)
  "Predicate function called for each candidate CAND given SOURCES.

Adopted from `consult--multi-predicate'"
  (let* ((src (consult--multi-source sources cand))
         (narrow (plist-get src :narrow))
         (type (or (car-safe narrow) narrow -1))
         (pred (plist-get src :predicate))
         (show t)
         )
    (if pred
        (cond
         ((booleanp pred)
          (setq show pred))
         ((and (functionp pred) (> (car (func-arity pred)) 0))
          (setq show (funcall pred cand)))))
      (and show
           (or (eq consult--narrow type)
               (not (or consult--narrow (plist-get src :hidden)))))))
#+end_src

***** multi-enabled
#+begin_src emacs-lisp
(defun consult-omni--multi-enabled-sources (sources)
  "Return vector of enabled SOURCES.

Adopted from `consult--multi-enabled-sources'."
  (vconcat
   (seq-filter (lambda (src)
                 (if-let (pred (plist-get src :enabled))
                     (cond
                      ((functionp pred)
                       (funcall pred))
                      (t
                       pred))
                   t))
               (mapcar (lambda (src)
                         (if (symbolp src) (symbol-value src) src))
                       sources))))
#+end_src
***** multi-propertize
#+begin_src emacs-lisp

(defun consult-omni--multi-propertize (response-items category pos &optional face)
  "Propertize RESPONSE-ITEMS with the multi-category datum and FACE.

POS and CATEGORY are the group ID and category for these items.

Adopted from `consult--multi-candidates'"
  (let ((annotated-items))
    (dolist (item response-items annotated-items)
      (if (consp item) (setq item (or (car-safe item) item)))
      (let* ((cand (consult--tofu-append item pos)))
        ;; Preserve existing `multi-category' datum of the candidate.
        (if (get-text-property 0 'multi-category cand)
            (when face (add-text-properties 0 (length item) face cand))
          ;; Attach `multi-category' datum and face.
          (add-text-properties 0 (length item)
                               `(multi-category (,category . ,item) ,@face) cand))
        (push cand annotated-items)))))

#+end_src
***** multi-annotate
#+begin_src emacs-lisp
(defun consult-omni--multi-annotate (sources cand)
  "Annotate candidate CAND from multi SOURCES.

Adopted from `consult--multi-annotate'"
  (let ((src (consult--multi-source sources cand)))
    (if-let ((fun (plist-get src :annotate)))
        (cond
         ((functionp fun)
          (funcall fun (cdr (get-text-property 0 'multi-category cand))))
         ((and (symbolp fun) (functionp (eval fun)))
          (funcall (eval fun) (cdr (get-text-property 0 'multi-category cand))))))
    ))
#+end_src
***** update candidates for synchronous sources (sync elisp)
#+begin_src emacs-lisp
(defun consult-omni--multi-update-sync-candidates (async source idx action &rest args)
"Asynchronously collects and returns candidates of a “sync” SOURCE

This returns the candidates with properties suitable
for use in a dynamically updated multi-source command
"

  (let* ((name (plist-get source :name))
         (face (and (plist-member source :face) `(face ,(plist-get source :face))))
         (cat (plist-get source :category))
         (transform (consult-omni--get-source-prop name :transform))
         (fun (plist-get source :items))
         (items))
    (when (functionp fun)
      (cond
       ((and (integerp (cdr (func-arity fun))) (< (cdr (func-arity fun)) 1))
        (setq items (funcall fun)))
       (t
        (setq items (funcall fun action args)))))
    (when (and items transform)
     (setq items (funcall transform items action)))
    (funcall async (and items (consult-omni--multi-propertize items cat idx face)))
    (funcall async 'refresh)
))
#+end_src







***** update candidates for dynamic sources (async elisp)
#+begin_src emacs-lisp
(defun consult-omni--multi-update-dynamic-candidates (async source idx action &rest args)
"Asynchronously collects and returns candidates of a “dynamic” SOURCE

This returns the candidates with properties suitable
for use in a dynamically updated multi-source command
"
  (let* ((name (plist-get source :name))
         (face (and (plist-member source :face) `(face ,(plist-get source :face))))
         (cat (plist-get source :category))
         (transform (consult-omni--get-source-prop name :transform)))
    (funcall (plist-get source :items) action
             :callback (lambda (response-items)
                         (when response-items
                           (when transform (setq response-items (funcall transform response-items action)))
                           (funcall async (consult-omni--multi-propertize response-items cat idx face))
                           (funcall async 'refresh)
                           )) args)))
#+end_src







***** update candidates for async sources (async process)
#+begin_src emacs-lisp
(defun consult-omni--multi-update-async-candidates (async source idx action &rest args)
  "Asynchronously collects and returns candidates of an “async” SOURCE

This returns the candidates with properties suitable
for use in a dynamically updated multi-source command
"
  (let* ((name (plist-get source :name))
         (builder (plist-get source :items))
         (transform (consult-omni--get-source-prop name :transform))
         (filter (consult-omni--get-source-prop name :filter))
         (props (seq-drop-while (lambda (x) (not (keywordp x))) args))
         (proc)
         (proc-buf)
         (count)
         (face (and (plist-member source :face) `(face ,(plist-get source :face))))
         (consult-omni--async-log-buffer (concat " *consult-omni-async-log--" name "*"))
         (cat (plist-get source :category))
         (query (car (consult-omni--split-command action)))
         (args (funcall builder action)))
    (unless (stringp (car args))
        (setq args (car args)))
      (when proc
        (delete-process proc)
        (kill-buffer proc-buf)
        (setq proc nil proc-buf nil))
      (when args
        (let* ((rest "")
               (proc-filter
                (lambda (_ out)
                  (let* ((lines (split-string out "[\r\n]+")))
                    (if (not (cdr lines))
                        (setq rest (concat rest (car lines)))
                      (setcar lines (concat rest (car lines)))
                      (let* ((len (length lines))
                             (last (nthcdr (- len 2) lines)))
                        (setq rest (cadr last)
                              count (+ count len -1))
                        (setcdr last nil)
                        (when lines
                          (when (and filter (functionp filter)) (setq lines (funcall filter lines query)))
                          (when (and transform (functionp transform))
                            (setq lines (funcall transform lines query)))
                          (setq lines (mapcar (lambda (line) (propertize line :source name :title line :query query)) lines))
                          (funcall async (consult-omni--multi-propertize lines cat idx face))
                          (funcall async 'refresh))
                        )))))
               (proc-sentinel
                (lambda (_ event)
                  (funcall async 'indicator
                           (cond
                            ((string-prefix-p "killed" event)   'killed)
                            ((string-prefix-p "finished" event) 'finished)
                            (t 'failed)))
                  (when (and (string-prefix-p "finished" event) (not (equal rest "")))
                    (cl-incf count)
                    (funcall async (list rest)))
                  (consult-omni--async-log
                   "consult--async-process sentinel: event=%s lines=%d\n"
                   (string-trim event) count)
                  (when (> (buffer-size proc-buf) 0)
                    (with-current-buffer (get-buffer-create consult-omni--async-log-buffer)
                      (goto-char (point-max))
                      (insert ">>>>> stderr >>>>>\n")
                      (let ((beg (point)))
                        (insert-buffer-substring proc-buf)
                        (save-excursion
                          (goto-char beg)
                          (message #("%s" 0 2 (face error))
                                   (buffer-substring-no-properties (pos-bol) (pos-eol)))))
                      (insert "<<<<< stderr <<<<<\n")))))
               (process-adaptive-read-buffering nil))
          (funcall async 'indicator 'running)
          (consult-omni--async-log "consult--async-process started %S\n" args)
          (setq count 0
                proc-buf (generate-new-buffer (concat " *consult-omni-async-stderr-" name "*"))
                proc (apply #'make-process
                            `(,@props
                              :connection-type pipe
                              :name ,(car args)
                              :process-buffer ,proc-buf
                              :noquery t
                              :command ,args
                              :filter ,proc-filter
                              :sentinel ,proc-sentinel)))))
    (when proc (add-to-list 'consult-omni-async-processes `(,proc . ,proc-buf)))))
#+end_src

***** consult-omni--multi-cancel
#+begin_src emacs-lisp
(defun consult-omni--multi-cancel ()
"Kill asynchronous subprocesses created for async multi-source commands."
  (mapcar (lambda (proc) (when proc (delete-process (car proc))
                               (kill-buffer (cdr proc))
                               ))
          consult-omni-async-processes)
  (setq consult-omni-async-processes nil)
  (mapcar (lambda (timer) (when timer (cancel-timer timer))) consult-omni-dynamic-timers)
  (setq consult-omni-dynamic-timers nil))
#+end_src


***** consult-omni--multi-update-candidates
#+begin_src emacs-lisp

(defun consult-omni--multi-update-candidates (async sources action &rest args)
  "Dynamically updates CANDIDATES for multiple SOURCES

ASYNC is the sink function

SOURCES are sources to use

ACTION is the action argument passed to ASYNC.
See `consult--async-sink' for more info
"
  (let ((idx 0))
    (seq-doseq (src sources)
      (let* ((name (plist-get src :name))
             (items (plist-get src :items))
             (narrow (plist-get src :narrow))
             (async-type (consult-omni--get-source-prop name :type))
             (narrow-type (or (car-safe narrow) narrow -1))
             (err (if consult-omni-log-level 'err nil)))
        (when (or (eq consult--narrow narrow-type)
                  (not (or consult--narrow (plist-get src :hidden))))
          (condition-case err
              (progn
                (when (functionp items)
                  (cond
                   (; sync source, append candidates right away
                    (equal async-type 'sync)
                    (consult-omni--multi-update-sync-candidates async src idx action args)
                    )
                   (; async source, append candidatesin process
                    (equal async-type 'async)
                    (consult-omni--multi-update-async-candidates async src idx action args)
                    )
                    (; dynamic source, append candidates in a callback function
                     (equal async-type 'dynamic)
                     (consult-omni--multi-update-dynamic-candidates async src idx action args)

                     )
                    (t
                     (message "source %s needs a :type keyword. See the documentation for `consult-omni-define-source'." name
                              )))
                   ))
                ('error ;; message other erros
                 (funcall async 'indicator 'killed)
                 (message (if consult-omni-log-level
                              (format "error in calling :items of %s source - %s" name (error-message-string err))
                            (format "error in calling :items of %s source" name)))
                 nil)
                )))
        (cl-incf idx))
      ))
#+end_src

***** collect candidates form multiple sources
#+begin_src emacs-lisp
(defun consult-omni--multi-dynamic-collection (async sources &rest args)
  "Dynamic computation of candidates.

ASYNC is the sink command
SOURCES is list of sources to use

This is a generalized replacement for `consult--async-process',
and `consult--dynamic-collection' that allows collecting candidates from
synchronous (e.g. elisp funciton with no input args),
dynamic (e.g. elip function with input args),
or asynchronous (e.g. shell process) SOURCES
"
  (setq async (consult--async-indicator async))
  (let ((consult-omni-async-processes (list))
        (consult-omni-dynamic-timers (list))
        (current))
    (lambda (action)
      (pcase action
        ('nil
         (funcall async nil))
        (""
         (setq current nil)
         (consult-omni--multi-cancel)
         (funcall async 'flush)
         (funcall async 'indicator 'finished)
         )
        ((pred stringp)
         (if (equal action current)
             (funcall async 'indicator 'finished)
           (progn
             (setq current action)
             (consult-omni--multi-update-candidates async sources action args)
             (funcall async 'refresh))))
        ('destroy
         (consult-omni--multi-cancel)
         (funcall async 'destroy))
        (_ (funcall async action))))))
#+end_src



***** dynamic command
#+begin_src emacs-lisp
(defun consult-omni--multi-dynamic-command (sources &rest args)
"Dynamic collection with input splitting on multiple SOURCES.

This is a generalized form of `consult--async-command'
and `consult--dynamic-compute' that allow synchronous, dynamic
, and asynchronous sources."
(declare (indent 1))
(thread-first
  (consult--async-sink)
  (consult--async-refresh-timer)
  (consult-omni--multi-dynamic-collection sources args)
  (consult--async-throttle)
  (consult--async-split)))
#+end_src

***** consult-omni--multi-dynamic
#+begin_src emacs-lisp
(cl-defun consult-omni--multi-dynamic (sources args &rest options)
"Select candidates with dynamic input from a list of SOURCES.

This is similar to `consult--multi'
but with dynamic update of candidates
and accepts async (shell commands simlar to `consult--grep')
, or dynamic sources (elisp functions like `consult-line-multi') as well.

OPTIONS are similar to options in `consult--multi'.
See `consult--multi' for more info.

ARGS are sent as additional args to each source
collection function.
"
 (let* ((sources (consult-omni--multi-enabled-sources sources))
         (selected
          (apply #'consult--read
                 (consult-omni--multi-dynamic-command sources args)
                 (append
                  options
                  (list
                   :sort        nil
                   :history     '(:input consult-omni--search-history)
                   :initial     (consult--async-split-initial nil)
                   :category    'multi-category
                   :predicate   (apply-partially #'consult-omni--multi-predicate sources)
                   :annotate    (apply-partially #'consult-omni--multi-annotate sources)
                   :group       (apply-partially #'consult-omni--multi-group sources)
                   :lookup      (apply-partially #'consult-omni--multi-lookup sources)
                   :preview-key (consult--multi-preview-key sources)
                   :narrow      (consult--multi-narrow sources)
                   :state       (consult--multi-state sources))))))
    (if (plist-member (cdr selected) :match)
        (when-let (fun (plist-get (cdr selected) :new))
          (funcall fun (car selected))
          (plist-put (cdr selected) :match 'new))
      (when-let (fun (plist-get (cdr selected) :action))
        (funcall fun (car selected)))
      (setq selected `(,(car selected) :match t ,@(cdr selected))))
    selected))
#+end_src


** Macro
*** make a variable for source
**** make symbol for source name
#+begin_src emacs-lisp
(defun consult-omni--source-name (source-name &optional suffix)
  "Returns a symbol for SOURCE-NAME variable.

The variable is consult-omni--source-%s (%s=source-name).
Adds suffix to the name if provided."
  (intern (format "consult-omni--source-%s" (concat (replace-regexp-in-string " " "-" (downcase source-name)) (if suffix (downcase suffix) nil)))))

#+end_src
**** make generic docstring for varibale of source
#+begin_src emacs-lisp

(defun consult-omni--source-generate-docstring (source-name)
  "Makes a generic documentation string for SOURCE-NAME.

This is used in `consult-omni-define-source' macro to make generic
docstrings for variables."
  (format "consult-omni source for %s.\n \nThis function was defined by the macro `consult-omni-define-source'."
          (capitalize source-name)))
#+end_src
*** make a function for source
**** make a function symbol for source
#+begin_src emacs-lisp

(defun consult-omni--func-name (source-name &optional prefix suffix)
  "Make a function symbol witth SOURCE-NAME.

This is used to make interactive command symbols.

Adds PREFIX and SUFFIX if non-nil."
  (intern (concat "consult-omni-" (if prefix prefix) (replace-regexp-in-string " " "-" (downcase source-name)) (if suffix suffix))))
#+end_src
**** make generic doctring for function of source
#+begin_src emacs-lisp

(defun consult-omni--func-generate-docstring (source-name &optional dynamic)
  "Make a generic documentaion string for an interactive command.

This is used to make docstring for function made by `consult-omni-define-source'."
  (concat "consult-omni's " (if dynamic "dynamic ") (format "interactive command to search %s."
                                                             (capitalize source-name))))
#+end_src
*** make a consult--read source list
#+begin_src emacs-lisp
(defun consult-omni--make-source-list (source-name request annotate face narrow-char state preview-key category lookup group require-match sort enabled predicate select-hist)
  "Internal function to make a source for `consult-omni--multi'.

Do not use this function directly, use `consult-omni-define-source' macro
instead. Refer to `consult-omni-define-source' for details on arguments."
  `(:name ,source-name
          ,(when (and annotate face) :face)
          ,(when (and annotate face) (cond
            ((eq face t)
             'consult-omni-default-face)
            (t face)))
          :narrow ,narrow-char
          :state ,(or state #'consult-omni--dynamic-state-function)
          :category ,(or category 'consult-omni)
          :history ,select-hist
          :add-history (delq nil
                                    (cl-remove-duplicates
                                     (append (mapcar (lambda (thing) (consult-omni-dynamic--split-thingatpt thing))
                                             (list 'number 'word 'sexp 'symbol 'url 'filename 'sentence 'line)) (list isearch-string))))
          :items  ,request
          :annotate ,(cond
                      ((and annotate (functionp annotate))
                       annotate)
                      ((eq annotate t)
                       #'consult-omni--annotate-function)
                      (t nil))
          :lookup ,(if (and lookup (functionp lookup))
                      lookup
                    #'consult-omni--lookup-function)
          :group ,(or group #'consult-omni--group-function)
          :preview-key ,(and consult-omni-show-preview (or preview-key consult-omni-preview-key))
          ,(when enabled ':enabled)
          ,(when enabled enabled)
          :sort ,sort
          ,(when predicate ':predicate)
          ,(when predicate predicate)
          :require-match ,require-match
          ))
#+end_src
*** make a static interactive command
#+begin_src emacs-lisp

(defun consult-omni--call-static-command (input prompt no-callback args request face state source-name category lookup select-hist-var annotate preview-key sort)
  "Internal function to make static `consult--read' command.

Do not use this function directly, use `consult-omni-define-source' macro
instead. Refer to `consult-omni-define-source' for details on arguments."
  (let* ((input (or input
                    (and consult-omni-default-autosuggest-command (funcall-interactively consult-omni-default-autosuggest-command))
                    (consult-omni--read-search-string)))

         (prompt (or prompt (concat "[" (propertize (format "%s" (consult-omni--func-name source-name)) 'face 'consult-omni-prompt-face) "]" " Search: ")))
         (selected (consult-omni--multi-static (list (consult-omni--source-name source-name))
                                               input
                                               args
                                               :prompt prompt
                                               :sort sort
                                               :history select-hist-var))
         (match (plist-get (cdr selected) :match))
         (source  (plist-get (cdr selected) :name))
         (selected (cond
                    ((consp selected) (car-safe selected))
                    (t selected)))
         (selected (if match selected (string-trim selected (consult--async-split-initial nil))))
         ;; (source (get-text-property 0 :source selected))
         (callback-func (and (not no-callback)
                             (or (and match source (consult-omni--get-source-prop source :on-callback))
                                 (and source (consult-omni--get-source-prop source :on-new))))))
    (when (functionp callback-func)
      (funcall callback-func selected))
    selected)
  )

#+end_src
*** make a dynamic interactive command
#+begin_src emacs-lisp
(defun consult-omni--call-dynamic-command (initial prompt no-callback args source-name request category face lookup search-hist-var select-hist-var preview-key sort)
  "Internal function to make dynamic `consult--read' command.

Do not use this function directly, use `consult-omni-define-source' macro
instead. Refer to `consult-omni-define-source' for details on arguments."
  (let* ((consult-async-refresh-delay consult-omni-dynamic-refresh-delay)
         (consult-async-input-throttle consult-omni-dynamic-input-throttle)
         (consult-async-input-debounce consult-omni-dynamic-input-debounce)
         (prompt (or prompt (concat "[" (propertize (format "%s" (consult-omni--func-name source-name)) 'face 'consult-omni-prompt-face) "]" " Search: ")))
         (selected (consult-omni--multi-dynamic (list (consult-omni--source-name source-name))
                                                args
                                                :prompt prompt
                                                :history '(:input search-hist-var)
                                                :initial (consult--async-split-initial initial)
                                                :sort sort
                                                ))
         (match (plist-get (cdr selected) :match))
         (source  (plist-get (cdr selected) :name))
         (selected (cond
                    ((consp selected) (car selected))
                    (t selected)))
         (selected (if match selected (string-trim selected (consult--async-split-initial nil))))
         (title (get-text-property 0 :title selected))
         (callback-func (and (not no-callback)
                             (or (and match source (consult-omni--get-source-prop source :on-callback))
                                 (and source (consult-omni--get-source-prop source :on-new)))
                             )))
    (add-to-history select-hist-var title)
    (when (functionp callback-func)
      (funcall callback-func selected))
    selected
    ))
#+end_src
*** macro to add a new source

#+begin_src emacs-lisp
;;; Macros
;;;###autoload
(cl-defmacro consult-omni-define-source (source-name &rest args &key type request transform filter on-setup on-preview on-return on-exit state on-callback on-new require-match static lookup group narrow-char category search-hist select-hist face annotate enabled sort predicate preview-key docstring  &allow-other-keys)
  "Macro to make a consult-omni-source for SOURCE-NAME.

\* Makes
- a source plist
- interactive commands (static or dynamic) for single source
- adds a new row to to `consult-omni-sources-alist' with all the
metadata as a property list.

\* Keyword Arguments

Brief Description:

==========   ====================  ============================================
Keyword      Type                  Explanation
==========   ====================  ============================================

TYPE         (sync|dynamic|async)  How to collect items for source?

REQUEST      (function)            Fetch results from source

TRANSFORM    (funciton)            Function to transform/format candidates

FILTER       (funciton)            Function to filter candidates

ON-SETUP     (function)            Setup action in `consult--read'

ON-PREVIEW   (function)            Preview action in `consult--read'

ON-RETURN    (function)            Return action in `consult--read'

ON-EXIT      (function)            Exit action in `consult--read'

STATE        (function)            STATE passed to `consult--read'
                                   (bypasses ON-PREVIEW and ON-RETURN)

ON-CALLBACK  (function)            Function called on selected candidate

ON-NEW       (function)            Function called on non-existing candidate

REUIRE-MATCH (function)            Can non-matching candidates be selected

STATIC      (boolean|'both)        Whether to make static commands or not

LOOKUP       (function)            Lookup function for `consult--read'

GROUP       (function)             Passed as GROUP to `consult--read'

NARROW-CHAR (char)                Passed as NARROW to `consult-read'

CATEGORY    (symbol)              Passed as CATEGORY to `consult--read'

SEARCH-HIST (symbol)              Passed as HISTORY to `consult--read'

SELECT-HIST (symbol)              Collects list of selected items

FACE        (face)                Passed as FACE to `consult--read-multi'

ANNOTATE    (function)            Passed as ANNOTATE to `consult--read'

ENABLED     (function)            Passed as ENABLED to `consult--read'

SORT        (boolean)             Passed as SORT to `consult--read'

PREDICATE   (function)            Passed as PREDICATE to `consult--read'

PREVIEW-KEY (key)                 Passed as PREVIEW-KEY to `consult--read'

DOCSTRING   (string)              DOCSTRING for the variable created for SOURCE-NAME

===================================================================

Detailed Decription:

TYPE can be 'sync, 'dynamic or 'async, depending on how the items for
the source should be collected.
- 'sync sources get their candidates
from a synchronous elisp function (i.e. a function that returns a list).
- 'dynamic sources use an elisp function that runs asynchronousl to produce
list of candidates (e.g. a web request that runs in the background)
- 'async sources run a shell process (e.g. a command line command) asynchronously
and return the results (lines from stdout) as list of candidates.

Note that all three types can have dynamic completion
(meaning that the funciton takes an input argument and returns
the result base don the input), but the difference is whether the function
uses synchronous or asynchronous collection and whether it is an elsip funciton
or a shell subprocess.


REQUEST is a function that returns the list of candidates.
- In synchronous sources, REQEUEST can take 0 or 1 input argument,
and returns a list of candidates.
- In asynchronous sources, REQUEST takes at least 1 input argument, and returns
a list of strings that are command line process arguments.
- In dynamic sources, REQUEST takes at least 1 input argument and a keyword
argument called callback. The callback should be called with candidates as
input in the body. Here is the recommended format;
(cl-defun REQUEST (input &rest args &key callback &allow-other-keys)
BODY
(when callback (funcall callback candidates))
candidates
)

See `consult-omni--brave-fetch-results' and `consult-omni--grep-builder'
for examples.

For synchronous sources, REQUEST should take at least one input argument
as well as a keyword argument called callback. The input argument is the string
from the user input in the minibuffer. Body of the function builds the list of candidates
and passes it to callback. The format should look like this:

(cl-defun consult-omni--elfeed-fetch-results (input &rest args &key callback &allow-other-keys)
BODY
(funcall callback candidates)
)

Examples can be found in the wiki pages of the repo or in
“consult-omni-sources.el” on the repository webpage or :
URL `https://github.com/armindarvish/consult-omni/blob/main/consult-omni-sources.el'


TRANSFORM is a function that takes a list of candidates (e.g. strings)
and optionally the query string and returns a list of transformed/formatted
strings. It's called with `(funcall tranform candidates query)`.
This is especially useful for async sources
where the process returns a list of candiate strings, in which case TRANSFORM
is applied to all candiates using `mapcar'.
See `consult-omni--grep-transform' for an example.

FILTER is a function that takes a list of candidates (e.g. strings)
and optionally the query string and returns a list of filtered
strings. It's called with `(funcall filter candidates query)`.
This is especially useful for async sources
where the process returns a list of candiate strings, in which case FILTER
is applied to all candidates using `seq-filter'.
See `consult-omni--locate-filter' for an example.



ON-SETUP is a function called when setting up the minibuffer.
This is used inside an state funciton by `consult--read.
See and its `consult--read' and state functions for more info.


ON-PREVIEW is used as a function to call on the candidate, when a preview is
requested. It takes one required argument, the candidate. For an example,
see `consult-omni-default-preview-function'.


ON-RETURN is used as a function to call on the candidate, when the
candidate is selected. This is passed to consult built-in state
function machinery.
Note that the output of this function will be returned in the consult-omni
commands. In consult-omni, ON-CALLBACK is used to call further actions on
this returned value. This allows to separate the return value from the
commands and the action that run on the selected candidates. Therefore
for most use cases, ON-RETURN can just be `#'identity' to get
the candidate back as it is. But if some transformation is needed,
ON-RETURN can be used to transform the selected candidate.


ON-EXIT is a function called when exiting the minibuffer.
This is used inside an state funciton by `consult--read.
See `consult--read' and its state functions for more info.

STATE is a function that takes no argument and returns a function for
consult--read STATE argument. For an example see
`consult-omni--dynamic-state-function' that builds state function based on
 ON-PREVIEW and ON-RETURN. If STATE is non-nil, instead of using
ON-PREVIEW and ON-RETURN to make a state function, STATE will be directly
used in consult--read.


ON-CALLBACK is the function that is called with one required input argument,
 the selected candidate. For example, see `consult-omni--default-callback'
that opens the url of the candidate in the default browser.
Other examples can be found in the wiki pages of the repo or in
“consult-omni-sources.el” on the repository webpage or :
URL `https://github.com/armindarvish/consult-omni/blob/main/consult-omni-sources.el'


ON-NEW is similiar to ON-CALLBACK but for new non-pre-existing candidates,
in oter words the minibuffer content itself. This is useful for example in
autosuggestion commands, to get the query itself with norather than a suggestion.


REQUIRE-MATCH is a boolean. When non-nil non-matching candidates (e.g.
the minibuffer content itself) can be selected as a candidate.


STATIC can be a boolean (nil or t) or the symbol 'both.
If nil only \*non-dynamic\* interactive commands are created in this macro.
if t only \*dynamic\* interactive commands are created in this macro.
If something else (e.g. 'both) \*Both\* dynamic and non-dynamic commands
are created.


LOOKUP, GROUP, ANNOTATE, NARROW-CHAR, CATEGORY, ENABLED, SORT,
and PREVIEW-KEY are passed to `consult--read'.
See consult's Documentaion for more details.


SEARCH-HIST, and SELECT-HIST are history list varibales used
to keep records of search terms and selected candidates, respectively.


FACE is used to format the candidate. This is useful for simple formating
without making using TRANSFORM or formatin candidates inside the REQUEST
funciton.


DOCSTRING is used as docstring for the variable consult-omni--source-%s
variable that this macro creates for %s=SOURCE-NAME.
"
  (if (symbolp source-name) (setq source-name (eval source-name)))

  `(progn

     ;; make a variable called consult-omni--source-%s (%s=source-name)
     (defvar ,(consult-omni--source-name source-name) nil)
     (setq ,(consult-omni--source-name source-name) (consult-omni--make-source-list ,source-name ,request ,annotate ,face ,narrow-char ,state ,preview-key ,category ,lookup ,group ,require-match ,sort ,enabled ,predicate ,select-hist))
      ;; make a dynamic interactive command consult-omni-dynamic-%s (%s=source-name)
     (unless (eq ,static t)
         (defun ,(consult-omni--func-name source-name) (&optional initial prompt no-callback &rest args)
           ,(or docstring (consult-omni--func-generate-docstring source-name t))
           (interactive "P")
           (consult-omni--call-dynamic-command initial prompt no-callback args ,source-name ,request ,category ,face ,lookup ,search-hist ,select-hist ,preview-key ,sort)
           ))

     ;; make a static interactive command consult-omni-%s (%s=source-name)
     (if ,static
       (defun ,(consult-omni--func-name source-name nil "-static") (&optional input prompt no-callback &rest args)
         ,(or docstring (consult-omni--func-generate-docstring source-name))
         (interactive "P")
         (consult-omni--call-static-command input prompt no-callback args ,request ,face ,state ,source-name ,category ,lookup ,select-hist ,annotate ,preview-key ,sort)
         ))

     ;; add source to consult-omni-sources-alist
     (add-to-list 'consult-omni-sources-alist (cons ,source-name
                                                          (list :name ,source-name
                                                                :type ,type
                                                                :require-match ,require-match
                                                                :source (consult-omni--source-name ,source-name)
                                                                :face ,face
                                                                :request-func ,request
                                                                :transform ,transform
                                                                :filter ,filter
                                                                :on-setup ,on-setup
                                                                :on-preview (or ,on-preview #'consult-omni--default-url-preview)
                                                                :on-return (or ,on-return #'identity)
                                                                :on-exit ,on-exit
                                                                :on-callback (or ,on-callback #'consult-omni--default-callback)
                                                                :on-new (or ,on-new #'consult-omni--default-new)
                                                                :state ,state
                                                                :group ,group
                                                                :annotate ,annotate
                                                                :narrow-char ,narrow-char
                                                                :preview-key ,preview-key
                                                                :category (or ',category 'consult-omni)
                                                                :search-hist ,search-hist
                                                                :select-hist ,select-hist
                                                                :interactive-static (and (functionp (consult-omni--func-name ,source-name)) (consult-omni--func-name ,source-name nil "-static"))
                                                                :interactive-dynamic (and (functionp (consult-omni--func-name ,source-name)) (consult-omni--func-name ,source-name))
                                                                :enabled ,enabled
                                                                :sort ,sort
                                                                :predicate ,predicate
                                                                )))

     ,source-name))

#+end_src
*** make source for consult-omni from consult source
**** make fetch function
#+begin_src emacs-lisp
;;;###autoload
(cl-defmacro consult-omni--make-fetch-function (source &rest args &key source-name docstring &allow-other-keys)
  "Make a function for fetching result based on SOURCE.

SOURCE is a source for consult (e.g. a plist that is passed
to consult--multi). See `consult-buffer-sources' for examples.

SOURCE-NAME is a string name for SOURCE

DOCSTRING is the docstring for the function that is returned."
  (let* ((source (if (plistp source) source (eval source)))
        (source-name (substring-no-properties (plist-get source :name))))
  `(progn
     ;; make a function that creates a consult--read source for consult-omni-multi
     (cl-defun ,(consult-omni--source-name source-name "-fetch-results") (input &rest args &key callback &allow-other-keys)
       ,(or docstring (consult-omni--source-generate-docstring source-name))
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input args))
         (opts (car-safe opts))
         (fun  (plist-get ',source :items))
         (results (cond
                   ((functionp fun) (funcall fun))
                   ((listp fun) fun)
                   ))
         (source (substring-no-properties (plist-get ',source :name))))
    (delq nil (mapcar (lambda (item)
                        (if (consp item) (setq item (or (car-safe item) item)))
              (when (string-match (concat ".*" query ".*") item)
                  (propertize item
                              :source source
                              :title item
                              :url nil
                              :query query
                              :search-url nil
                              ))) results)))))))
#+end_src
**** define source
#+begin_src emacs-lisp

(cl-defun consult-omni--make-source-from-consult-source (consult-source &rest args &key type request transform on-setup on-preview on-return on-exit state on-callback on-new group narrow-char category static search-hist select-hist face annotate enabled sort predicate preview-key docstring &allow-other-keys)
"Makes a consult-omni source from a consult source plist, CONSULT-SOURCE.

All other input variables are passed to `consult-omni-define-source'
macro. See `consult-omni-define-source' for more details"
  (if (boundp consult-source)
        (let* ((source (eval consult-source))
               (source (if (plistp source) source (eval source)))
               (name (and (plistp source) (substring-no-properties (plist-get source :name))))
               (narrow-char (or narrow-char (and (plistp source) (plist-get source :narrow))))
               (narrow-char (if (listp narrow-char) (car narrow-char)))
               (face (or face (and (plistp source) (plist-get source :face))))
               (state (or state (and (plistp source) (plist-get source :state))))
               (annotate (cond
                          ((eq annotate 'nil) nil)
                          ((eq annotate 't) (and (plistp source) (plist-get source :annotate)))
                          (t annotate)))
               (preview-key (or preview-key (and (plistp source) (plist-get source :preview-key)) consult-omni-preview-key))
               (predicate (or predicate (and (plistp source) (plist-get source :predicate))))
               (group (or group (and (plistp source) (plist-get source :group))))
               (sort (or sort (and (plistp source) (plist-get source :sort))))
               (enabled (or enabled (and (plistp source) (plist-get source :enabled))))
               (category (or category (and (plistp source) (plist-get source :category)) 'consult-omni)))
          (eval (macroexpand
           `(consult-omni-define-source ,name
                                     :docstring ,docstring
                                     :narrow-char ,narrow-char
                                     :face ',face
                                     :category ',category
                                     :type ',type
                                     :request (or ,request (consult-omni--make-fetch-function ,source))
                                     :transform ,transform
                                     :on-setup ',on-setup
                                     :on-preview ',on-preview
                                     :on-return ',on-return
                                     :on-exit ',on-exit
                                     :on-callback ',on-callback
                                     :on-new ',on-new
                                     :preview-key ,preview-key
                                     :search-hist ',search-hist
                                     :select-hist ',select-hist
                                     :enabled ',enabled
                                     :predicate ',predicate
                                     :group ',group
                                     :sort ',sort
                                     :static ',static
                                     :annotate ',annotate
                                     ))))
    (display-warning :warning (format "consult-omni: %s is not available. Make sure `consult-notes' is loaded and set up properly" consult-source)))
  )
#+end_src
** Frontend Interactive commands
*** consult-omni-multi
#+begin_src emacs-lisp

(defun consult-omni-multi (&optional initial prompt sources no-callback &rest args)
  "Interactive “multi-source dynamic search”

INITIAL is the initial search prompt in the minibuffer.
PROMPT is thean optional minibuffer prompt
Searches all sources in SOURCES. if SOURCES is nil
`consult-omni-multi-sources' is used.
If NO-CALLBACK is t, only the selected candidate is returned without
any callback action.

This is an interactive command that fetches results form
all the sources in either SOURCES or in `consult-omni-multi-sources'
with dynamic completion meaning that the search term can be dynamically
updated by the user and the results are fetched as
the user types in the miinibuffer.

Additional commandline arguments can be passed in the minibuffer
entry similar to `consult-grep' by typing `--` followed by arguments.
These additional arguments are passed to async sources
similar to `consult-grep' syntax. In addition, other arguments can be passed
to all sources by using key, val pairs (.e.g “:group domain”)

For example the user can enter:

`#consult-omni -- :g domain'

This will run a search on all the sources for
the term “consult-omni” and then groups the results by the “domain
of the URL” of the results.

Built-in arguments include:

 :g, or :group for grouping (see `consult-omni-group-by' and `consult-omni--override-group-by'. for more info)

 :n, or :count is passed as the value for COUNT
to any source in `consult-omni-multi-sources'.

 :p, or :page is passed as the value for PAGE to any source
 in `consult-omni-multi-sources'.

Custom arguments can be passed by using “:ARG value”.
For example, if the user types the following in the minibuffer:
“#how to do web search in emacs? -- :model gpt-4”
The term “how to do web search in emacs?” is passed as the search
term and the “gpt-4” as a keyword argument for :model to every
source in `consult-omni-multi-sources'. If any request function of
the sources takes a keyword argument for :model, “gpt-4” is
used then.

Once the results are fetched, narrowing down can be done by
using consult-split-style syntax (e.g. “#” for “perl” style)
after the serach term, similar to `consult-grep'.
For example:
“#consult-omni#github.com”
uses “consult-omni” as the search term, and then narrows the choices to
results that have “github.com” in them.

For more examples, refer to the official documentation of the repo here:
URL `https://github.com/armindarvish/consult-omni'.

For more details on consult--async functionalities, you can also
see `consult-grep' and the official manual of consult,
here: URL `https://github.com/minad/consult'."
  (interactive "P")
  (let* ((consult-async-refresh-delay consult-omni-dynamic-refresh-delay)
         (consult-async-input-throttle consult-omni-dynamic-input-throttle)
         (consult-async-input-debounce consult-omni-dynamic-input-debounce)
         (sources (or sources consult-omni-multi-sources))
         (sources (remove nil (mapcar (lambda (source) (plist-get (cdr (assoc source consult-omni-sources-alist)) :source)) sources)))
         (prompt (or prompt (concat "[" (propertize "consult-omni-multi" 'face 'consult-omni-prompt-face) "]" " Search:  ")))
         (selected
          (consult-omni--multi-dynamic
                     sources
                     args
                     :prompt prompt
                     :sort t
                     :history '(:input consult-omni--search-history)
                     :initial (consult--async-split-initial initial)
                     ))
         (match (plist-get (cdr selected) :match))
         (source  (plist-get (cdr selected) :name))
         (selected (cond
                    ((consp selected) (car-safe selected))
                    (t selected)))
         (selected (if match selected (string-trim selected (consult--async-split-initial nil))))
         (callback-func (and (not no-callback)
                             (or (and match source (consult-omni--get-source-prop source :on-callback))
                                 (and source (consult-omni--get-source-prop source :on-new)))
                             )))

    (when (functionp callback-func)
      (funcall callback-func selected))

    selected
    ))

#+end_src
*** consult-omni-multi-static
#+begin_src emacs-lisp
(defun consult-omni-multi-static (&optional input prompt sources no-callback &rest args)
  "Interactive “static” multi-source search

INPUT is the initial search query. Searches all sources
in SOURCES for INPUT.
If SOURCES is nil, `consult-omni-multi-sources' is used.
If NO-CALLBACK is t, only the selected candidate is returned
without any callback action.
"
  (interactive "P")
  (let* ((input (or input
                    (and consult-omni-default-autosuggest-command  (funcall consult-omni-default-autosuggest-command))
                    (consult-omni--read-search-string)))
         (input (if (stringp input) (substring-no-properties input)))
         (sources (or sources consult-omni-multi-sources))
         (sources (remove nil (mapcar (lambda (source) (consult-omni--get-source-prop source :source))  sources)))
         (prompt (or prompt (concat "[" (propertize "consult-omni-multi-static" 'face 'consult-omni-prompt-face) "]" " Search:  ")))
         (selected (consult-omni--multi-static sources
                                               input
                                               args
                                               :prompt prompt
                                               :history 'consult-omni--selection-history
                                               :sort t
                                               ))
         (match (plist-get (cdr selected) :match))
         (source  (plist-get (cdr selected) :name))
         (selected (cond
                    ((consp selected) (car-safe selected))
                    (t selected)))
         (selected (if match selected (string-trim selected (consult--async-split-initial nil))))
         (callback-func (and (not no-callback)
                             (or (and match source (consult-omni--get-source-prop source :on-callback))
                                 (and source (consult-omni--get-source-prop source :on-new)))
                             )))

    (when (functionp callback-func)
      (funcall callback-func selected))
    selected
    ))
#+end_src
*** consult-omni
#+begin_src emacs-lisp
(defun consult-omni (&rest args)
"Convinient wrapper function for favorite interactive command.

Calls the function in `consult-omni-default-interactive-command'.
"
  (interactive)
  (apply consult-omni-default-interactive-command args))
#+end_src
** Provide and Footer
#+begin_src emacs-lisp
;;; provide `consult-omni' module

(provide 'consult-omni)

;;; consult-omni.el ends here
#+end_src

* embark
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./consult-omni-embark.el
:END:
** Header
#+begin_src emacs-lisp
;;; consult-omni-embark.el --- Embark Actions for `consult-omni' -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish


;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: ((emacs "28.1") (consult "1.4") (consult-omni "0.1"))
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:

;;; Code:
#+end_src
** Requirements
#+begin_src emacs-lisp
;;; Requirements

(require 'embark)
(require 'consult-omni)

#+end_src
** Define Group, Customs, Vars, Etc.
*** customization variables
#+begin_src emacs-lisp
;;; Customization Variables
(defcustom consult-omni-embark-default-term  #'eshell
  "consult-omni default terminal to use in embark actions"
  :type '(choice (function :tag "(Default) eshell" #'eshell)
                 (function :tag "shell" #'shell)
                 (function :tag "term" #'term)
                 (function :tag "ansi-term" #'ansi-term)
                 (function :tag "vterm" #'vterm)
                 (function :tag "vterm" #'eat)
                 (function :tag "Custom Function" function)))

#+end_src

*** other variables
*** define faces

** General
*** actions
#+begin_src emacs-lisp
;;; Define Embark Action Functions

(defun consult-omni-embark-default-action (cand)
  "Calls the default action on CAND.

Gets the default callback function from `consult-omni-sources-alist'."
  (let* ((source (and (stringp cand) (get-text-property 0 :source cand))))
    (funcall (consult-omni--get-source-prop source :on-callback) cand))
  )

(add-to-list 'embark-default-action-overrides '(consult-omni . consult-omni-embark-default-action))


(defun consult-omni-embark-insert-title (cand)
  "Insert the title oif the candidate at point"
  (if-let ((title (and (stringp cand) (get-text-property 0 :title cand))))
      (insert (format " %s " title))))

(defun consult-omni-embark-copy-title-as-kill (cand)
  "Copy the title of the candidate to `kill-ring'."
  (if-let ((title (and (stringp cand) (get-text-property 0 :title cand))))
      (kill-new (string-trim title))))

(defun consult-omni-embark-insert-url-link (cand)
  "Insert the title of the candidate at point."
  (let* ((url (and (stringp cand) (get-text-property 0 :url cand)))
         (url (and (stringp url) (string-trim url)))
         (title (and (stringp cand) (get-text-property 0 :title cand))))
    (when url
      (cond
       ((derived-mode-p 'org-mode)
        (insert (cond
                 ((and url title) (format " [[%s][%s]] " url title))
                 (url (format " [[%s]] " url))
                 (t ""))
                ))
       ((derived-mode-p 'markdown-mode)
        (insert (cond
                 ((and url title) (format " [%s](%s) " url title))
                 (url (format " <%s> " url))
                 (t ""))
                ))
       (t
        (insert (cond
                 ((and url title) (format " %s (%s) " title  url))
                 (url (format " %s " url))
                 (t ""))
                ))))))

(defun consult-omni-embark-copy-url-as-kill (cand)
  "Copy the url of the candidate to `kill-ring'."
  (if-let ((url (and (stringp cand) (get-text-property 0 :url cand))))
      (kill-new (format " %s " (string-trim url)))
    ))

(defun consult-omni-embark-external-browse-link (cand)
  "Open the url with `consult-omni-default-browse-function'"
  (if-let* ((url (and (stringp cand) (get-text-property 0 :url cand))))
      (funcall consult-omni-default-browse-function url)))

(defun consult-omni-embark-alternate-browse-link (cand)
  "Open the url with `consult-omni-alternate-browse-function'"
  (if-let* ((url (and (stringp cand) (get-text-property 0 :url cand))))
      (funcall consult-omni-alternate-browse-function url)))

(defun consult-omni-embark-external-browse-search-link (cand)
  "Open the search url (the source search page) in the external browser."
  (if-let* ((search-url (and (stringp cand) (get-text-property 0 :search-url cand))))
      (funcall #'browse-url search-url)))

(defun consult-omni-embark-show-preview (cand)
  "Get a preview of CAND.

Gets the preview function from `consult-omni-sources-alist'."
  (let* ((source (and (stringp cand) (get-text-property 0 :source cand))))
    (funcall (consult-omni--get-source-prop source :on-preview) cand))
  )

#+end_src
*** keymap
#+begin_src emacs-lisp

;;; Define Embark Keymaps

(defvar-keymap consult-omni-embark-general-actions-map
  :doc "Keymap for consult-omni-embark"
  :parent embark-general-map
  "i t"  #'consult-omni-embark-insert-title
  "i u" #'consult-omni-embark-insert-url-link
  "w t" #'consult-omni-embark-copy-title-as-kill
  "w u" #'consult-omni-embark-copy-url-as-kill
  "o o" #'consult-omni-embark-external-browse-link
  "o O" #'consult-omni-embark-alternate-browse-link
  "o s" #'consult-omni-embark-external-browse-search-link
  "o p" #'consult-omni-embark-show-preview
  )


(add-to-list 'embark-keymap-alist '(consult-omni . consult-omni-embark-general-actions-map))

#+end_src
** Scholar
*** variables
#+begin_src emacs-lisp
(defcustom consult-omni-embark-scholar-make-note-func  #'consult-omni-embark-scholar-default-note
  "function for template note for scholar article"
  :type '(choice (function :tag "(Default) Make Note with Title, Link, Journal, Authors... " consult-omni-embark-scholar-default-note)
                 (function :tag "Custom Function" function)))
#+end_src
*** actions
#+begin_src emacs-lisp
(defun consult-omni-embark-scholar-external-browse-doi (cand)
  "Open the DOI url in external browser"
  (if-let* ((doi (and (stringp cand) (get-text-property 0 :doi cand))))
      (funcall #'browse-url (concat "https://doi.org/" doi))))

(defun consult-omni-embark-scholar-copy-authors-as-kill (cand)
  "Copy the authors of CAND to `kill-ring'."
  (if-let ((authors (and (stringp cand) (get-text-property 0 :authors cand))))
      (kill-new (string-trim (format " %s " authors)))
    ))

(defun consult-omni-embark-scholar-insert-authors (cand)
  "Insert the authors of CAND at point."
  (if-let ((authors (and (stringp cand) (get-text-property 0 :authors cand))))
      (insert (string-trim (mapconcat #'identity authors ", ")))
    ))

(defun consult-omni-embark-scholar-default-note (cand)
  "Default function for making note templates.

This can be used for making notes for scholar articles.
"
  (let* ((url (and (stringp cand) (get-text-property 0 :url cand)))
         (url (and (stringp url) (string-trim url)))
         (doi (and (stringp cand) (get-text-property 0 :doi cand)))
         (doi (if (and doi (stringp doi)) (concat "https://doi.org/" doi)))
         (source (and (stringp cand) (get-text-property 0 :source cand)))
         (url (if (and (equal source "Scopus") doi)
                doi
                url))
         (title (and (stringp cand) (get-text-property 0 :title cand)))
         (authors (and (stringp cand) (get-text-property 0 :authors cand)))
         (authors (cond
                  ((and (listp authors) (= (length authors) 1))
                   (car authors))
                  ((listp authors)
                   (mapconcat #'identity authors ", "))
                  (t authors)))

         (journal  (and (stringp cand) (get-text-property 0 :journal cand)))
        (date (and (stringp cand) (get-text-property 0 :date cand))))

    (cond
      ((derived-mode-p 'org-mode)
       (concat
                "\n"
                (cond
                 ((and url title) (format "** [[%s][%s]]\n" url title))
                 (url (format "** [[%s]]\n" url))
                 (title (format "** %s\n" title)))
                (if authors (format "\n%s" authors))
                (if journal (format "\nin =%s= " journal))
                (if date (format "published on [%s]\n" date) "\n")
                "\n*** Notes\n"
                ))
      ((derived-mode-p 'markdown-mode)
       (concat
                "\n"
                (cond
                 ((and url title) (format "## [%s](%s)\n" url title))
                 (url (format "## <%s>\n" url))
                 (title (format "## %s\n" title)))
                (if authors (format "\n%s" authors))
                (if journal (format "\nin **%s** " journal))
                (if date (format "published on %s\n" date) "\n")
                "\n### Notes\n"
                ))
      (t
       (concat
                "\n"
                (cond
                 ((and url title) (format "** %s (%s)\n" title  url))
                 (url (format "** %s\n" url))
                 (title (format "** %s\n" title)))
                (if authors (format "\n%s" authors))
                (if journal (format "\nin %s " journal))
                (if date (format "published on %s\n" date) "\n")
                "\n*** Notes\n"
                ))

      )))

(defun consult-omni-embark-scholar-insert-note (cand)
  "Insert note snippet for article.

Uses `consult-omni-embark-scholar-make-note-func' to make template."
  (insert (funcall consult-omni-embark-scholar-make-note-func cand)))

#+end_src
*** keymap
#+begin_src emacs-lisp

(defvar-keymap consult-omni-embark-scholar-actions-map
  :doc "Keymap for consult-omni-embark-scholar"
  :parent consult-omni-embark-general-actions-map
  "o d" #'consult-omni-embark-scholar-external-browse-doi
  "w a" #'consult-omni-embark-scholar-copy-authors-as-kill
  "i a" #'consult-omni-embark-scholar-insert-authors
  "i n" #'consult-omni-embark-scholar-insert-note
  )

(add-to-list 'embark-keymap-alist '(consult-omni-scholar . consult-omni-embark-scholar-actions-map))

(add-to-list 'embark-default-action-overrides '(consult-omni-scholar . consult-omni-embark-default-action))

#+end_src





** Apps
*** actions
#+begin_src emacs-lisp
;;; Define Embark Action Functions

(defun consult-omni-embark-apps-open-filemanager (cand)
  "Open CAND's filepath sith system's file manager."
  (if-let* ((path (and (stringp cand) (get-text-property 0 :path cand))))
      (pcase system-type
        ('darwin (call-process "open" nil 0 nil path "-R"))
        ('cygwin (call-process "cygstart" nil 0 nil path))
        ('windows-nt (and (fboundp 'w32-shell-execute) (w32-shell-execute "open" path)))
        (_ (call-process "xdg-open" nil 0 nil path))
        )))

(defun consult-omni-embark-apps-find-file (cand)
  "Open CAND's filepath with `find-file'."
  (if-let* ((path (and (stringp cand) (get-text-property 0 :path cand)))
            (directory (and (file-exists-p (file-truename path)) (file-truename path)))
            (default-directory directory))
      (call-interactively #'find-file)))

(defun consult-omni-embark-apps-open-externally (cand)
  "Open FILE or url using system's default application."
  (if-let ((path (and (stringp cand) (get-text-property 0 :path cand))))
    (pcase system-type
      ('darwin (call-process "open" nil 0 nil path))
      ('cygwin (call-process "cygstart" nil 0 nil path))
      ('windows-nt (and (fboundp 'w32-shell-execute) (w32-shell-execute "open" path)))
      (_ (call-process "xdg-open" nil 0 nil path))
        )
    nil))

(defun consult-omni-embark-apps-open-term (cand)
  "Open CAND's filepath in `consult-omni-embark-default-term'."
  (if-let* ((path (and (stringp cand) (get-text-property 0 :path cand)))
            (directory (and (file-exists-p (file-truename path)) (file-truename path)))
            (default-directory directory))
      (funcall consult-omni-embark-default-term)))

(defun consult-omni-embark-apps-insert-path (cand)
  "Insert the title of CAND at point"
  (if-let ((path (and (stringp cand) (get-text-property 0 :path cand))))
      (insert (format " %s " path))))

(defun consult-omni-embark-apps-copy-path-as-kill (cand)
  "Insert the title of CAND at point"
  (if-let ((path (and (stringp cand) (get-text-property 0 :path cand))))
       (kill-new (format " %s " path))))
#+end_src
*** keymap
#+begin_src emacs-lisp

;;; Define Embark Keymaps

(defvar-keymap consult-omni-embark-apps-actions-map
  :doc "Keymap for consult-omni-embark"
  :parent consult-omni-embark-general-actions-map
  "x"  #'consult-omni-embark-apps-open-externally
  "f"  #'consult-omni-embark-apps-find-file
  "o f"  #'consult-omni-embark-apps-find-file
  "o o" #'consult-omni-embark-apps-open-filemanager
  "o t" #'consult-omni-embark-apps-open-term
  "w p" #'consult-omni-embark-apps-copy-path-as-kil
  )

(add-to-list 'embark-keymap-alist '(consult-omni-apps . consult-omni-embark-apps-actions-map))
(add-to-list 'embark-default-action-overrides '(consult-omni-apps . consult-omni-embark-default-action))

#+end_src
** Calc
*** actions
#+begin_src emacs-lisp
;;; Define Embark Action Functions

(defun consult-omni-embark-calc-copy-results-as-kill (cand)
  "Copy the results of the calculator to `kill-ring'."
  (if-let ((results (and (stringp cand) (get-text-property 0 :title cand))))
      (kill-new (format " %s " results))
    ))

(defun consult-omni-embark-calc-insert-results (cand)
  "Insert the title of CAND at point"
  (if-let (results (and (stringp cand) (get-text-property 0 :title cand)))
      (insert (format " %s " results))))

(defun consult-omni-embark-calc-copy-formula-as-kill (cand)
  "Copy the results of the calculator to `kill-ring'."
  (if-let ((formula (and (stringp cand) (get-text-property 0 :query cand))))
      (kill-new (format " %s " formula))
    ))

(defun consult-omni-embark-calc-insert-formula (cand)
  "Insert the title of CAND at point"
  (if-let (formula (and (stringp cand) (get-text-property 0 :query cand)))
      (insert (format " %s " formula))))

#+end_src
*** keymap
#+begin_src emacs-lisp

;;; Define Embark Keymaps

(defvar-keymap consult-omni-embark-calc-actions-map
  :doc "Keymap for consult-omni-embark"
  :parent embark-general-map
  "w r"  #'consult-omni-embark-calc-copy-results-as-kill
  "w f"  #'consult-omni-embark-calc-copy-formula-as-kill
  "i r"  #'consult-omni-embark-calc-insert-results
  "i f"  #'consult-omni-embark-calc-insert-formula
  )

(add-to-list 'embark-keymap-alist '(consult-omni-calc . consult-omni-embark-calc-actions-map))
(add-to-list 'embark-default-action-overrides '(consult-omni-calc . consult-omni-embark-default-action))

#+end_src
** Video
*** variables
#+begin_src emacs-lisp
(defcustom consult-omni-embark-video-default-player  (executable-find "mpv")
  "consult-omni external video player.

Can be:
 - an elisp function that takes a URL argument (e.g. mpv-pay-url)
 - a string for external command line program
"
  :type '(choice (string :tag "(Default) mpv executable command" (executable-find "mpv"))
                 (function :tag "play with mpv package" mpv-play-url)
                 (function :tag "Custom Function" function)
                 (string :tag "Custom Executable Command" string)))
#+end_src

*** actions
#+begin_src emacs-lisp :lexical t
(defun consult-omni-play-url-with-app (url)
  "Plays video at URL with `consult-omni-embark-video-default-player'."
  (interactive (let* ((cand (consult-omni-youtube nil "Search Youtube:  " t))
                      (link (get-text-property 0 :url cand)))
                 (list link)))
  (cond
   ((stringp consult-omni-embark-video-default-player)
    (if-let ((cmd (executable-find consult-omni-embark-video-default-player)))
        (progn
          (start-process "consult-omni-mpv" nil cmd url)
          (message "Opening with %s ..." consult-omni-embark-video-default-player))
      (message "executable %s not found")
      ))
   ((symbolp consult-omni-embark-video-default-player)
    (if (functionp consult-omni-embark-video-default-player)
        (progn (funcall consult-omni-embark-video-default-player url)
               (message "Opening with %s ..." consult-omni-embark-video-default-player))
      (message "Symbol function definition is void: %s"  consult-omni-embark-video-default-player)))
   ))

(defun consult-omni-embark-video-play-with-app (cand)
  "Open CAND's video URL with `consult-omni-play-url-with-ap'."
  (if-let* ((url (and (stringp cand) (get-text-property 0 :url cand))))
      (consult-omni-play-url-with-app url)
    ))

#+end_src


*** keymap
#+begin_src emacs-lisp

(defvar-keymap consult-omni-embark-video-actions-map
  :doc "Keymap for consult-omni-embark-video"
  :parent consult-omni-embark-general-actions-map
  "o x" #'consult-omni-embark-video-play-with-app
  )

(add-to-list 'embark-keymap-alist '(consult-omni-video . consult-omni-embark-video-actions-map))

(add-to-list 'embark-default-action-overrides '(consult-omni-video . consult-omni-embark-default-action))

#+end_src


** Provide and Footer
#+begin_src emacs-lisp
;;; Provide `consul-web-embark' module

(provide 'consult-omni-embark)

;;; consult-omni-embark.el ends here
#+end_src
* sources
** Multi Sources
*** all sources
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-sources.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-omni-sources.el --- Sources for consult-omni -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: ((emacs "28.1") (consult "1.4") (consult-omni "0.1"))
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:

;;; Code:


(require 'consult-omni)
#+end_src
**** define all source modules
#+begin_src emacs-lisp
(setq consult-omni-sources--all-modules-list
      (list 'consult-omni-apps
            'consult-omni-bing
            'consult-omni-brave-autosuggest
            'consult-omni-brave
            'consult-omni-browser-history
            'consult-omni-buffer
            'consult-omni-calc
            'consult-omni-chatgpt
            'consult-omni-consult-notes
            'consult-omni-doi
            'consult-omni-duckduckgo
            'consult-omni-elfeed
            'consult-omni-find
            'consult-omni-gh
            'consult-omni-google
            'consult-omni-google-autosuggest
            'consult-omni-grep
            'consult-omni-ripgrep
            'consult-omni-gptel
            'consult-omni-invidious
            'consult-omni-line-multi
            'consult-omni-locate
            'consult-omni-mdfind
            'consult-omni-mu4e
            'consult-omni-notes
            'consult-omni-notmuch
            'consult-omni-numi
            'consult-omni-pubmed
            'consult-omni-scopus
            'consult-omni-stackoverflow
            'consult-omni-wikipedia
            'consult-omni-youtube))
#+end_src
**** add individual or list of sources
#+begin_src emacs-lisp
(defun consult-omni-sources--load-module (symbol)
"Loads feature SYMBOL"
(require symbol nil t))

(defun consult-omni-sources-load-modules (&optional list)
  "Loads the LIST of symbols.
If list is nil, loads `consult-omni-sources-modules-to-load'and if that is nil as well, loads `consult-omni-sources--all-modules-list'."
  (mapcar #'consult-omni-sources--load-module (or list consult-omni-sources-modules-to-load consult-omni-sources--all-modules-list)))
#+end_src
**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-sources' module

(provide 'consult-omni-sources)
;;; consult-omni-sources.el ends here
#+end_src
** Single Source
*** Desktop Apps
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-apps.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-omni-apps.el --- Consulting OS applications -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: ((emacs "28.1") (consult "1.4") (consult-omni "0.1"))
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:

;;; Code:

(require 'consult-omni)
(require 'xdg)
#+end_src

**** custom variables
#+begin_src emacs-lisp
(defcustom consult-omni-apps-paths (list)
  "List of directories that contain applications.
"
  :type '(repeat :tag "List of paths" directory))

(defcustom consult-omni-apps-use-cache nil
"Whether to use cache for getting list of apps?"
:type 'boolean)

(defcustom consult-omni-apps-open-command-args nil
  "Command line args to open an application"
  :type 'string)

(defcustom consult-omni-apps-regexp-pattern ""
"Regexp pattern to find system applications"
:type 'regexp)

(defcustom consult-omni-apps-default-launch-function #'consult-omni--apps-lauch-app
  "consult-omni default function to launch an app"
  :type '(choice (function :tag "(Default) Use System Shell" consult-omni--apps-lauch-app)
                 (function :tag "Custom Function")))

(pcase system-type
  ('darwin
   (setq consult-omni-apps-paths (append (file-expand-wildcards "/Applications/Adobe*") (list "/Applications" "/Applications/Utilities/" "/System/Applications/" "/System/Applications/Utilities/" "~/Applications/")))
   (setq consult-omni-apps-regexp-pattern ".*\\.app$")
   (setq consult-omni-apps-open-command-args "open -a")
   )
   ('gnu/linux
    (setq consult-omni-apps-xdg-data-home (if (fboundp 'xdg-data-home) (xdg-data-home)
                                           (let ((path (getenv "XDG_DATA_HOME")))
                                             (if (or (null path) (string= path ""))
                                                 nil
                                               (parse-colon-path path)))))
     (setq consult-omni-apps-xdg-data-dirs (if (fboundp 'xdg-data-dirs) (xdg-data-dirs)
                                           (let ((path (getenv "XDG_DATA_DIRS")))
                                             (if (or (null path) (string= path ""))
    nil
                                               (parse-colon-path path)))))
     (setq consult-omni-apps-paths (remove nil (mapcar (lambda (dir)
                                       (let ((path (and (stringp dir) (file-exists-p dir) (file-truename (expand-file-name "applications" dir)))))
                                              (and (stringp path) path)))
                                          (list consult-omni-apps-xdg-data-home
                                               consult-omni-apps-xdg-data-dirs
                                               "/usr/share"
                                               "/usr/local/share"))))
     (setq consult-omni-apps-regexp-pattern ".*\\.desktop$")
     (setq consult-omni-apps-open-command-args "gtk-launch")
    )
)
#+end_src

**** other variables
#+begin_src emacs-lisp
(defvar consult-omni-apps-cached-apps nil)

(defvar consult-omni-apps-cached-items nil)

#+end_src
**** helper functions
***** cmd args
#+begin_src emacs-lisp
(defun consult-omni--apps-cmd-args (app &optional file)
  (append (consult--build-args consult-omni-apps-open-command-args)
          (list (format "%s" app))
          (if (and file (file-exists-p (file-truename file))) (list (format "%s" file)))))
#+end_src

***** make process
#+begin_src emacs-lisp
(defun consult-omni--apps-lauch-app (app &optional file)
  (let* ((name (concat "consult-omni-" (file-name-base app)))
         (cmds (consult-omni--apps-cmd-args app file)))
    (make-process :name name
                :connection-type 'pipe
                :command cmds
                :buffer nil
                )
    nil))
#+end_src
***** open with
#+begin_src emacs-lisp
(defun consult-omni-open-with-app (&optional file app)
  (interactive)
  (if-let* ((file (or file (read-file-name "select file:")))
            (file (file-truename file))
            (app (or app (get-text-property 0 :app (consult-omni-apps-static ".*" "  " t)))))
      (consult-omni--apps-lauch-app (format "%s" app)
                                    (format "%s" (and (file-exists-p file) file)))))
#+end_src
***** preview
#+begin_src emacs-lisp
(defun consult-omni--apps-preview (cand)
  "Mdfind preview function."
(ignore))
#+end_src

***** callback
#+begin_src emacs-lisp
(defun consult-omni--apps-callback (cand)
  "Mdfind callback function."
  (let ((app (get-text-property 0 :app cand)))
    (funcall consult-omni-apps-default-launch-function app)
  ))
#+end_src

***** format
#+begin_src emacs-lisp
(cl-defun consult-omni--apps-format-candidates (&rest args &key source query title path face snippet visible &allow-other-keys)
"Formats the cnaiddates of `consult-omni-apps.

Files are entries from `consult-omni--apps-list-apps'.
QUERY is the query input from the user"
  (let* ((frame-width-percent (floor (* (frame-width) 0.1)))
         (source (and (stringp source) (propertize source 'face 'consult-omni-source-type-face)))
         (directory (and path (file-name-directory path)))
         (directory (and (stringp directory) (propertize directory 'face 'consult-omni-path-face)))
         ;; (filename (and path (file-name-nondirectory path)))
         ;; (filename (and (stringp filename) (propertize filename 'face 'consult-omni-path-face)))
         (snippet (and (stringp snippet) (consult-omni--set-string-width snippet (* 3 frame-width-percent))))
         (snippet (and (stringp snippet) (propertize snippet 'face 'consult-omni-snippet-face)))
         (match-str (and (stringp query) (consult--split-escaped query) nil))
         (face (or (consult-omni--get-source-prop source :face) face 'consult-omni-files-title-face))
         (title-str (propertize title 'face face))
         (title-str (consult-omni--set-string-width title-str (* 4 frame-width-percent)))
         (str (concat title-str
                      (unless visible "\s[Hidden App]")
                      (when snippet (concat "\t" snippet))
                      (when directory (concat "\t" directory))
                      ;; (when filename (concat "\t" (when directory directory) filename))
                      (when source (concat "\t" source))
                      )))
     (if consult-omni-highlight-matches
        (cond
         ((listp match-str)
          (mapcar (lambda (match) (setq str (consult-omni--highlight-match match str t))) match-str))
         ((stringp match-str)
          (setq str (consult-omni--highlight-match match-str str t)))))
    str))
#+end_src

**** items
***** get list of system apps
#+begin_src emacs-lisp
(defun consult-omni--apps-get-desktop-apps ()
  "Return a list of files for system apps

Finds all files that match `consult-omni-apps-regexp-pattern'
in `consult-omni-apps-paths'.
"
  (if (and consult-omni-apps-use-cache consult-omni-apps-cached-apps)
      consult-omni-apps-cached-apps
(let ((paths (if (stringp consult-omni-apps-paths)
                   (list consult-omni-apps-paths)
                 consult-omni-apps-paths)))
    (when (listp paths)
      (setq consult-omni-apps-cached-apps (cl-remove-duplicates (apply #'append (mapcar (lambda (path)
                          (when (file-exists-p path)
                          (directory-files path t consult-omni-apps-regexp-pattern t))) paths))))))))

(setq consult-omni-apps-cached-apps (consult-omni--apps-get-desktop-apps))
#+end_src

***** parse app for name, comment and exec
#+begin_src emacs-lisp
(defun consult-omni--apps-parse-app-file (file)
  (pcase system-type
         ('darwin
          (let ((name (file-name-base file))
                (comment nil)
                (exec (consult-omni--apps-cmd-args (file-name-nondirectory file))))
            (list name comment exec t)))
         ('gnu/linux
          (with-temp-buffer
            (insert-file-contents file)
            (goto-char (point-min))
            (let ((start (re-search-forward "^\\[Desktop Entry\\] *$" nil t))
                  (end (re-search-forward "^\\[" nil t))
                  (visible t)
                  name comment exec)
              (catch 'break
                (unless start
                  (throw 'break nil))

                (goto-char start)
                (when (re-search-forward "^\\(Hidden\\|NoDisplay\\) *= *\\(1\\|true\\) *$" end t)
                  (setq visible nil))
                (setq name (match-string 1))

                (goto-char start)
                (unless (re-search-forward "^Type *= *Application *$" end t)
                  (throw 'break nil))
                (setq name (match-string 1))

                (goto-char start)
                (unless (re-search-forward "^Name *= *\\(.+\\)$" end t)
                  (throw 'break nil))
                (setq name (match-string 1))

                (goto-char start)
                (when (re-search-forward "^Comment *= *\\(.+\\)$" end t)
                  (setq comment (match-string 1)))

                (goto-char start)
                (unless (re-search-forward "^Exec *= *\\(.+\\)$" end t)
                  ;; Don't warn because this can technically be a valid desktop file.
                  (throw 'break nil))
                (setq exec (match-string 1))

                (goto-char start)
                (when (re-search-forward "^TryExec *= *\\(.+\\)$" end t)
                  (let ((try-exec (match-string 1)))
                    (unless (locate-file try-exec exec-path nil #'file-executable-p)
                      (throw 'break nil))))

                  (list name comment exec visible)))))))
#+end_src


***** cached items
#+begin_src emacs-lisp
(defun consult-omni-apps--cached-items (files query)
(if (and consult-omni-apps-use-cache consult-omni-apps--cached-items)
    consult-omni-apps-cached-items
(setq consult-omni-apps-cached-items
 (mapcar (lambda (file)
             (pcase-let* ((source "Apps")
                          (`(,name ,comment ,exec ,visible) (consult-omni--apps-parse-app-file file))
                    (title (or name (file-name-base file) ""))
                    (app (and (stringp file) (file-exists-p file) (file-name-nondirectory file)))
                    (search-url nil)

                    (decorated (funcall #'consult-omni--apps-format-candidates :source source :query query :title title :path file :snippet comment :visible visible)))
               (propertize decorated
                           :source source
                           :title title
                           :url nil
                           :search-url nil
                           :query query
                           :snippet comment
                           :path file
                           :exec exec
                           :app app)))
           (if query
               ;; (seq-filter (lambda (file) (string-match (concat ".*" query ".*") file nil t)) files)
               (cl-remove-if-not (lambda (file) (string-match (concat ".*" query ".*") file nil t)) files)
             files)
   ))))

(setq consult-omni-apps--cached-items  (consult-omni-apps--cached-items consult-omni-apps-cached-apps ".*"))

#+end_src
***** items
#+begin_src emacs-lisp

(cl-defun consult-omni--apps-list-apps (input &rest args &key callback &allow-other-keys)
  "get a list of applications from OS.
"
 (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (seq-difference args (list :callback callback))))
               (opts (car-safe opts))
               (count (plist-get opts :count))
               (count (or (and count (integerp (read count)) (string-to-number count))
                             consult-omni-default-count))
               (files (consult-omni--apps-get-desktop-apps)))
   (if (and consult-omni-apps-use-cache query)
       (seq-filter (lambda (file) (string-match (concat ".*" query ".*") file nil t)) consult-omni-apps-cached-items)
   (mapcar (lambda (file)
             (pcase-let* ((source "Apps")
                          (`(,name ,comment ,exec ,visible) (consult-omni--apps-parse-app-file file))
                    (title (or name (file-name-base file) ""))
                    (app (and (stringp file) (file-exists-p file) (file-name-nondirectory file)))
                    (search-url nil)
                    (decorated (funcall #'consult-omni--apps-format-candidates :source source :query query :title title :path file :snippet comment :visible visible)))
               (propertize decorated
                           :source source
                           :title title
                           :url nil
                           :search-url nil
                           :query query
                           :snippet comment
                           :path file
                           :exec exec
                           :app app)))
           (if query
               ;; (seq-filter (lambda (file) (string-match (concat ".*" query ".*") file nil t)) files)
             (cl-remove-if-not (lambda (file) (string-match (concat ".*" query ".*") file nil t)) files)
             files)
   )
 )))
#+end_src

**** define source
#+begin_src emacs-lisp

(consult-omni-define-source "Apps"
                           :narrow-char ?A
                           :category 'consult-omni-apps
                           :type 'sync
                           :require-match t
                           :request #'consult-omni--apps-list-apps
                           :on-preview #'ignore
                           :on-return #'identity
                           :on-callback #'consult-omni--apps-callback
                           :preview-key nil
                           :search-hist 'consult-omni--search-history
                           :select-hist 'consult-omni--apps-select-history
                           :enabled (lambda () (boundp 'consult-omni-apps-paths))
                           :group #'consult-omni--group-function
                           :sort t
                           :static 'both
                           :annotate nil
                           :category 'file
                           )
#+end_src
**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-apps module

(provide 'consult-omni-apps)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-apss)
;;; consult-omni-apps.el ends here
#+end_src

*** Bing
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-bing.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-omni-bing.el --- Consulting Bing -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: ((emacs "28.1") (consult "1.4") (consult-omni "0.1"))
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:

;;; Code:
(require 'consult-omni)
#+end_src
**** custom variables
#+begin_src emacs-lisp
(defcustom consult-omni-bing-search-api-key nil
  "Key for Bing (Microsoft Azure) search API

See URL `https://www.microsoft.com/en-us/bing/apis/bing-web-search-api' and URL `https://learn.microsoft.com/en-us/bing/search-apis/bing-web-search/search-the-web' for details"
  :group 'consult-omni
  :type '(choice (const :tag "API Key" string)
                 (function :tag "Custom Function")))

(defvar consult-omni-bing-search-api-url "https://api.bing.microsoft.com/v7.0/search")

#+end_src
**** items
#+begin_src emacs-lisp

(cl-defun consult-omni--bing-fetch-results (input &rest args &key callback &allow-other-keys)
  "Fetches search results for INPUT from Bing web search api.

Refer to URL `https://programmablesearchengine.google.com/about/' and `https://developers.google.com/custom-search/' for more info.
"
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (seq-difference args (list :callback callback))))
               (opts (car-safe opts))
               (count (plist-get opts :count))
               (page (plist-get opts :page))
               (count (or (and count (integerp (read count)) (string-to-number count))
                          consult-omni-default-count))
               (page (or (and page (integerp (read page)) (string-to-number page))
                         consult-omni-default-page))
               (count (max count 1))
               (page (* page count))
               (params `(("q" . ,(replace-regexp-in-string " " "+" query))
                         ("count" . ,(format "%s" count))
                         ("offset" . ,(format "%s" page))))
               (headers `(("Ocp-Apim-Subscription-Key" . ,(consult-omni-expand-variable-function consult-omni-bing-search-api-key)))))
    (consult-omni--fetch-url consult-omni-bing-search-api-url consult-omni-http-retrieve-backend
                            :encoding 'utf-8
                            :params params
                            :headers headers
                            :parser #'consult-omni--json-parse-buffer
                            :callback
                            (lambda (attrs)
                              (let* ((raw-results (map-nested-elt attrs '("webPages" "value")))
                                     (search-url (gethash "webSearchUrl" attrs))
                                     (annotated-results
                                      (mapcar (lambda (item)
                                                (let*
                                                    ((source "Bing")
                                                     (url (format "%s" (gethash "url" item)))
                                                     (title (gethash "name" item))
                                                     (snippet (gethash "snippet" item))
                                                     (decorated (funcall consult-omni-default-format-candidate :source source :query query :url url :search-url search-url :title title :snippet snippet)))
                                                  (propertize decorated
                                                              :source source
                                                              :title title
                                                              :url url
                                                              :search-url search-url
                                                              :query query
                                                              :snippet snippet)))

                                              raw-results)))
                                (when (and annotated-results (functionp callback))
                                  (funcall callback annotated-results))
                                annotated-results)))))

#+end_src
**** define source
#+begin_src emacs-lisp

(consult-omni-define-source "Bing"
                           :narrow-char ?i
                           :type 'dynamic
                           :require-match t
                           :face 'consult-omni-engine-title-face
                           :request #'consult-omni--bing-fetch-results
                           :preview-key consult-omni-preview-key
                           :search-hist 'consult-omni--search-history
                           :select-hist 'consult-omni--selection-history
                           :enabled (lambda () (bound-and-true-p consult-omni-bing-search-api-key))
                           :group #'consult-omni--group-function
                           :sort t
                           :static 'both
                           :annotate nil
                           )

#+end_src
**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-bing' module

(provide 'consult-omni-bing)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-bing)
;;; consult-omni-bing.el ends here
#+end_src


*** Brave
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-brave.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-omni-brave.el --- Consulting Brave -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: ((emacs "28.1") (consult "1.4") (consult-omni "0.1"))
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:

;;; Code:

(require 'consult-omni)
#+end_src


**** custom variables
#+begin_src emacs-lisp
(defcustom consult-omni-brave-api-key nil
  "Key for Brave API.

See URL `https://brave.com/search/api/' for more info"
  :group 'consult-omni
  :type '(choice (const :tag "Brave API Key" string)
                 (function :tag "Custom Function")))

(defvar consult-omni-brave-search-url "https://search.brave.com/search")

(defvar consult-omni-brave-url "https://api.search.brave.com/res/v1/web/search")

#+end_src
**** get items
#+begin_src emacs-lisp

(cl-defun consult-omni--brave-fetch-results (input &rest args &key callback &allow-other-keys)
  "Retrieve search results from Brave for INPUT.
"
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (seq-difference args (list :callback callback))))
               (opts (car-safe opts))
               (count (plist-get opts :count))
               (page (plist-get opts :page))
               (count (or (and count (integerp (read count)) (string-to-number count))
                          consult-omni-default-count))
               (page (or (and page (integerp (read page)) (string-to-number page))
                         consult-omni-default-page))
               (count (min (max count 1) 20))
               (params `(("q" . ,(replace-regexp-in-string " " "+" query))
                         ("count" . ,(format "%s" count))
                         ("page" . ,(format "%s" page))))
               (headers `(("User-Agent" . "Emacs:consult-omni/0.1 (Emacs consult-omni package; https://github.com/armindarvish/consult-omni)")
                          ("Accept" . "application/json")
                          ("Accept-Encoding" . "gzip")
                          ("X-Subscription-Token" . ,(consult-omni-expand-variable-function consult-omni-brave-api-key)))))
    (consult-omni--fetch-url consult-omni-brave-url consult-omni-http-retrieve-backend
      :encoding 'utf-8
      :params params
      :headers headers
      :parser #'consult-omni--json-parse-buffer
      :callback
      (lambda (attrs)
        (when-let* ((raw-results (map-nested-elt attrs '("web" "results")))
                    (annotated-results
                     (mapcar (lambda (item)
                               (let*
                                   ((source "Brave")
                                    (url (gethash "url" item))
                                    (title (gethash "title" item))
                                    (snippet (gethash "description" item))
                                    (search-url (consult-omni--make-url-string consult-omni-brave-search-url params))
                                    (decorated (funcall consult-omni-default-format-candidate :source source :query query :url url :search-url search-url :title title :snippet snippet)))
                                 (propertize decorated
                                             :source source
                                             :title title
                                             :url url
                                             :search-url search-url
                                             :query query
                                             :snippet snippet)))
                             raw-results)))
          (funcall callback annotated-results)
          annotated-results)))))

#+end_src
**** define source
#+begin_src emacs-lisp

;; Define the Brave Source
(consult-omni-define-source "Brave"
                           :narrow-char ?b
                           :type 'dynamic
                           :require-match t
                           :face 'consult-omni-engine-title-face
                           :request #'consult-omni--brave-fetch-results
                           :preview-key consult-omni-preview-key
                           :search-hist 'consult-omni--search-history
                           :select-hist 'consult-omni--selection-history
                           :enabled (lambda () (bound-and-true-p consult-omni-brave-api-key))
                           :group #'consult-omni--group-function
                           :sort t
                           :static 'both
                           )
#+end_src

**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-brave' module

(provide 'consult-omni-brave)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-brave)
;;; consult-omni-brave.el ends here
#+end_src
*** Brave AutoSuggest
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-brave-autosuggest.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-omni-brave-autosuggest.el --- Consulting Brave Autosuggest -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: ((emacs "28.1") (consult "1.4") (consult-omni "0.1"))
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:

;;; Code:

(require 'consult-omni)
#+end_src
**** custom variables
#+begin_src emacs-lisp

(defcustom consult-omni-brave-autosuggest-api-key nil
  "Key for Brave Autosuggest API.

See URL `https://brave.com/search/api/' for more info"
  :group 'consult-omni
  :type '(choice (const :tag "Brave Autosuggest API Key" string)
                 (function :tag "Custom Function")))

(defvar consult-omni-brave-autosuggest-api-url "https://api.search.brave.com/res/v1/suggest/search")

#+end_src
**** helper functions
***** return
#+begin_src emacs-lisp
(defun consult-omni--brave-autosuggest-return (cand)
  "Return the string of CAND with no properties
"
(when (stringp cand)
  (substring-no-properties (string-trim cand))))

#+end_src
**** get items
#+begin_src emacs-lisp

(cl-defun consult-omni--brave-autosuggest-fetch-results (input &rest args &key callback &allow-other-keys)
  "Fetch search results for INPUT from Brave Autosuggest API.
"
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (seq-difference args (list :callback callback))))
               (opts (car-safe opts))
               (count (plist-get opts :count))
               (page (plist-get opts :page))
               (count (or (and count (integerp (read count)) (string-to-number count))
                          consult-omni-default-count))
               (page (or (and page (integerp (read page)) (string-to-number page))
                         consult-omni-default-page))
               (count (min (max count 1) 20))
               (params  `(("q" . ,(replace-regexp-in-string " " "+" query))
                          ("count" . ,(format "%s" count))
                          ("page" . ,(format "%s" page))
                          ("country" . "US")))
               (headers `(("User-Agent" . "Emacs:consult-omni/0.1 (Emacs consult-omni package; https://github.com/armindarvish/consult-omni)")
                          ("Accept" . "application/json")
                          ("Accept-Encoding" . "gzip")
                          ("X-Subscription-Token" . ,(consult-omni-expand-variable-function consult-omni-brave-autosuggest-api-key))
                          )))
    (consult-omni--fetch-url consult-omni-brave-autosuggest-api-url consult-omni-http-retrieve-backend
                             :encoding 'utf-8
                             :params params
                             :headers headers
                             :parser #'consult-omni--json-parse-buffer
                             :callback
                             (lambda (attrs)
                               (when-let* ((original (make-hash-table :test 'equal))
                                           (_ (puthash "query" (gethash "original" (gethash "query" attrs)) original))
                                           (raw-results  (append (map-nested-elt attrs '("results")) (list original)))
                                           (annotated-results
                                            (mapcar (lambda (item)
                                                      (let* ((source "Brave AutoSuggest")
                                                             (word (gethash "query" item))
                                                             (url (concat "https://search.brave.com/search?q="  (replace-regexp-in-string " " "+" word)))
                                                             (urlobj (and url (url-generic-parse-url url)))
                                                             (domain (and (url-p urlobj) (url-domain urlobj)))
                                                             (domain (and (stringp domain)
                                                                          (propertize domain 'face 'font-lock-variable-name-face)))
                                                             (path (and (url-p urlobj) (url-filename urlobj)))
                                                             (path (and (stringp path)
                                                                        (propertize path 'face 'font-lock-warning-face)))
                                                             (search-url nil)
                                                             (decorated (propertize word 'face 'consult-omni-default-face)))
                                                        (propertize decorated
                                                                    :source source
                                                                    :title word
                                                                    :url url
                                                                    :search-url search-url
                                                                    :query query)))

                                                    raw-results)))
                                 (funcall callback annotated-results)
                                 annotated-results)))))

#+end_src
**** define source
#+begin_src emacs-lisp

(consult-omni-define-source "Brave AutoSuggest"
                           :narrow-char ?B
                           :type 'dynamic
                           :require-match nil
                           :face 'consult-omni-engine-title-face
                           :request #'consult-omni--brave-autosuggest-fetch-results
                           :group #'consult-omni--group-function
                           :on-preview #'ignore
                           :on-return #'consult-omni--brave-autosuggest-return
                           :on-callback #'string-trim
                           :search-hist 'consult-omni--search-history
                           :select-hist t
                           :enabled (lambda () (bound-and-true-p consult-omni-brave-autosuggest-api-key))
                           :sort t
                           :static nil
                           )
#+end_src
**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-brave-autosuggest' module

(provide 'consult-omni-brave-autosuggest)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-brave-autosuggest)
;;; consult-omni-brave-autosuggest.el ends here
#+end_src
*** browser history
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-browser-history.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-omni-browser-history.el --- Consulting Browser History -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: ((emacs "28.1") (consult "1.4") (consult-omni "0.1") (browser-hist "0.0.1"))
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:

;;; Code:

(require 'consult-omni)
(require 'browser-hist)

#+end_src
**** helper functions
***** format
#+begin_src emacs-lisp

(cl-defun consult-omni--browser-history-format-candidate (&rest args &key source query url search-url title face &allow-other-keys)
  "Formats candidates of `consult-omni-browser-history'.

SOURCE is the name string of the source for candidate

QUERY is the query string used for searching

URL is a string pointing to url of the candidate

SEARCH-URL is a string pointing to the url for
the search results of QUERY on the SOURCE website

TITLE is the title of the candidate

SNIPPET is a string containing a snippet/description of candidate
"
  (let* ((frame-width-percent (floor (* (frame-width) 0.1)))
         (source (and (stringp source) (propertize source 'face 'consult-omni-source-type-face)))
         (match-str (and (stringp query) (consult--split-escaped query) nil))
         (face (or (consult-omni--get-source-prop source :face) face 'consult-omni-default-face))
         (title-str (propertize title 'face face))
         (title-str (consult-omni--set-string-width title-str (* 4 frame-width-percent)))
         (urlobj (and url (url-generic-parse-url url)))
         (domain (and (url-p urlobj) (url-domain urlobj)))
         (domain (and (url-p urlobj) (or (url-domain urlobj) (url-host urlobj))))
         (port (and (url-p urlobj) (url-port urlobj)))
         (domain (if port (format "%s:%s" domain port) (format "%s" domain)))
         (domain (and (stringp domain) (propertize domain 'face 'consult-omni-domain-face)))
         (path (and (url-p urlobj) (url-filename urlobj)))
         (path (and (stringp path) (propertize path 'face 'consult-omni-path-face)))
         (url-str (consult-omni--set-url-width domain path (* frame-width-percent 5)))
         (str (concat title-str
                      (when url-str (concat "\s" url-str))
                      (when source (concat "\t" source)))))
    (if consult-omni-highlight-matches
        (cond
         ((listp match-str)
          (mapcar (lambda (match) (setq str (consult-omni--highlight-match match str t))) match-str))
         ((stringp match-str)
          (setq str (consult-omni--highlight-match match-str str t)))))
    str))
#+end_src
**** items
#+begin_src emacs-lisp
(cl-defun consult-omni--browser-history-fetch-results (input &rest args &key callback &allow-other-keys)
  "Fetch search results for INPUT from browser history.
"
 (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (seq-difference args (list :callback callback))))
               (opts (car-safe opts))
               (browser (or (plist-get opts :browser) browser-hist-default-browser))
               (browser-hist-default-browser browser)
               (results (browser-hist--send-query query))
               (source "Browser History"))
      (mapcar (lambda (item)
                (let* ((url (car-safe item))
                      (title (cdr-safe item))
                      (decorated (consult-omni--browser-history-format-candidate :source source :query query :url url :title title)))
                  (propertize decorated
                              :source source
                              :title title
                              :url url
                              :query query)))
              results)))
#+end_src
**** define source
#+begin_src emacs-lisp

(consult-omni-define-source "Browser History"
                           :narrow-char ?H
                           :type 'sync
                           :require-match nil
                           :face 'consult-omni-engine-title-face
                           :request #'consult-omni--browser-history-fetch-results
                           :preview-key consult-omni-preview-key
                           :search-hist 'consult-omni--search-history
                           :select-hist 'consult-omni--selection-history
                           :enabled (lambda () (fboundp 'browser-hist-search))
                           :group #'consult-omni--group-function
                           :sort t
                           :static 'both
                           :annotate nil
                           )
#+end_src
**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-browser-history' module

(provide 'consult-omni-browser-history)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-browser-history)
;;; consult-omni-browser-history.el ends here
#+end_src
*** calc
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-calc.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-omni-calc.el --- Consulting Emacs Calculator -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: ((emacs "28.1") (consult "1.4") (consult-omni "0.1"))
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:

;;; Code:

(require 'consult-omni)
(require 'calc)
(require 'calc-aent nil t)
#+end_src
**** variables
***** custom
#+begin_src emacs-lisp
(defcustom consult-omni-calc-number-only nil
"Only show calculator results when the query result in a nunmber?"
:type 'boolean)

(defcustom consult-omni-calc-message-errors nil
"Whether to message errors for calc?

Setting this to non-nil will show messages
when the calcultor cannot find results
"
:type 'boolean)

#+end_src
**** helper functions
***** callback
#+begin_src emacs-lisp
(defun consult-omni--calc-callback (cand)
  "Copys the result as well as formula to kill ring."
  (let ((equ (get-text-property 0 :query cand))
        (result  (get-text-property 0 :title cand)))
  (kill-new (concat equ " => " result))
  (kill-new result)))
#+end_src

**** items
#+begin_src emacs-lisp
(cl-defun consult-omni--calc-fetch-results (input &rest args &key callback &allow-other-keys)
  "Calculate the result of possible math equations.

This uses `calc-eval' to return the result of input"
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (seq-difference args (list :callback callback))))
               (source "calc")
               (opts (car-safe opts))
               (opts (cl-substitute :convert :c opts :test 'equal))
               (convert (plist-get opts :convert))
               (extra-args (plist-get opts :$))
               (extra-args (and extra-args (car (read-from-string extra-args))))
               (extra-args (if (listp extra-args) extra-args (list extra-args)))
               (extra-args (mapcar (lambda (item) (cond
                                                   ((numberp item) (format "%s" item))
                                                   ((and (symbolp item) (numberp (symbol-value item))) (format "%s" (symbol-value item)))
                                                   ((and (functionp item) (numberp (funcall item))) (format "%s" (funcall item)))
                                                   ((and (numberp (eval item))) (format "%s" (eval item)))
                                                   (t item))
                                     ) extra-args))
               (calc-eval-error t)
               (result)
               (annotated-result)
               )
    (when (string-match "[[:digit:]\/\*\+-=%^&$\(\{\[]" query nil t)
      (condition-case err
          (if convert
              (cl-letf* (((symbol-function 'calc-convert-units)
                          (symbol-function 'calc-convert-exact-units)))
                (setq result (cond
                              ((string-match-p ".*deg.*" convert)
                               (setq result (calc-eval (math-convert-temperature (apply #'calc-eval (list query) 'raw extra-args) (apply #'calc-eval (list (replace-regexp-in-string "[[:digit:]\s$]+" "" query extra-args)) 'raw extra-args) (calc-eval (list convert) 'raw)))))
                              (t (calc-eval (math-convert-units (apply #'calc-eval (list query) 'raw extra-args) (calc-eval (list convert) 'raw)))))))
          (if consult-omni-calc-number-only
              (setq result (apply #'calc-eval (list query) 'num extra-args))
            (setq result (apply #'calc-eval (list query) nil extra-args))))
        ('error (and consult-omni-calc-message-errors (message (error-message-string err))))
        ))

     (when result (setq annotated-result (propertize result
                                        :source source
                                        :title result
                                        :url nil
                                        :query query
                                        )))
     (if annotated-result
        (list annotated-result)
       nil)
    ))

#+end_src
**** define source
#+begin_src emacs-lisp

(consult-omni-define-source "calc"
                           :narrow-char ?c
                           :category 'consult-omni-calc
                           :type 'sync
                           :require-match t
                           :face 'consult-omni-date-face
                           :request #'consult-omni--calc-fetch-results
                           :on-preview #'ignore
                           :on-return #'identity
                           :on-callback #'consult-omni--calc-callback
                           :preview-key consult-omni-preview-key
                           :search-hist 'consult-omni--search-history
                           :select-hist 'consult-omni--selection-history
                           :enabled (lambda () (fboundp 'calc-eval))
                           :group #'consult-omni--group-function
                           :sort t
                           :static nil
                           :annotate nil
                           )
#+end_src

**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-calc' module

(provide 'consult-omni-calc)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-calc)
;;; consult-omni-calc.el ends here
#+end_src


*** chatGPT
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-chatgpt.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-omni-chatgpt.el --- Consulting chatGPT -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: ((emacs "28.1") (consult "1.4") (consult-omni "0.1"))
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:

;;; Code:

(require 'consult-omni)
#+end_src
**** variables
***** custom
#+begin_src emacs-lisp

(defcustom consult-omni-openai-api-key nil
"Key for OpeAI API

See URL `https://openai.com/product' and URL `https://platform.openai.com/docs/introduction' for details"
:group 'consult-omni
:type '(choice (const :tag "API Key" string)
               (function :tag "Custom Function")))
#+end_src
***** other
#+begin_src emacs-lisp
(defvar consult-omni-chatgpt-api-url "https://api.openai.com/v1/chat/completions")
#+end_src
**** helper functions
***** format
#+begin_src emacs-lisp
(defun consult-omni-dynamic--chatgpt-format-candidate (source query title &optional model face)
  "Formats candidates of `consult-omni-chatgpt'.

SOURCE is the name to use (e.g. “chatgPT”)

QUERY is the query input from the user

TITLE is the title of the candidate (e.g. response from chatgpt)

MODEL is the model used

FACE is the face to apply to TITLE
"
  (let* ((source (if (stringp source) (propertize source 'face 'consult-omni-source-type-face)))
         (title-str (consult-omni--set-string-width title (floor (* (frame-width) 0.4))))
         (title-str (propertize title-str 'face (or face 'consult-omni-ai-title-face)))
         (str (concat title-str "\t"
                      (propertize " " 'display '(space :align-to center))
                      (if model (propertize (format "model: %s" model) 'face 'consult-omni-path-face))
                      (if source (concat "\t" source))))
         (match-str (if (stringp query) (consult--split-escaped query) nil))
         )
    (if consult-omni-highlight-matches
        (cond
         ((listp match-str)
          (mapcar (lambda (match) (setq str (consult-omni--highlight-match match str t))) match-str))
         ((stringp match-str)
          (setq str (consult-omni--highlight-match match-str str t)))))
    str))
#+end_src

***** preview
#+begin_src emacs-lisp
(defun consult-omni--chatgpt-response-preview (response &optional query)
  "Returns a buffer with formatted RESPONSE from chatGPT"
  (save-excursion
    (let ((buff (get-buffer-create "*consult-omni-chatgpt-response*")))
      (with-current-buffer buff
        (erase-buffer)
        (if query (insert (format "# User:\n\n %s\n\n" query)))
        (if response (insert (format "# chatGPT:\n\n %s\n\n" response)))
        (if (featurep 'mardown-mode)
            (require 'markdown-mode)
          (markdown-mode)
          )
        (point-marker))
      )))


(defun consult-omni--chatgpt-preview (cand)
  "Shows a preview buffer with chatGPT response from CAND"
  (when-let ((buff (get-buffer "*consult-omni-chatgpt-response*")))
    (kill-buffer buff))

  (if (listp cand) (setq cand (or (car-safe cand) cand)))
  (when-let*  ((query  (get-text-property 0 :query cand))
               (response (or (get-text-property 0 :title cand) cand))
               (marker (consult-omni--chatgpt-response-preview response query)))
    (consult--jump marker)
))
#+end_src

**** items
#+begin_src emacs-lisp
(cl-defun consult-omni--chatgpt-fetch-results (input &rest args &key callback &allow-other-keys)
  "Fetches chat response for INPUT from chatGPT."
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (seq-difference args (list :callback callback))))
               (opts (car-safe opts))
               (model (or (plist-get opts :model) "gpt-3.5-turbo"))
               (headers `(("Content-Type" . "application/json")
                          ("Authorization" . ,(concat "Bearer " (consult-omni-expand-variable-function consult-omni-openai-api-key))))))
    (consult-omni--fetch-url consult-omni-chatgpt-api-url
                             consult-omni-http-retrieve-backend
                             :type "POST"
                             :encoding 'utf-8
                             :headers headers
                             :data  (json-encode `((model . ,model)
                                                   (messages . [((role . "user")
                                                                 (content . ,query))])))
                             :parser #'consult-omni--json-parse-buffer
                             :callback
                             (lambda (attrs)
                               (let* ((source "chatGPT")
                                      (url nil)
                                      (search-url nil)
                                      (choices (car-safe (gethash "choices" attrs)))
                                      (title (and choices (map-nested-elt choices '("message" "content"))))
                                      (model model)
                                      (decorated (consult-omni-dynamic--chatgpt-format-candidate source query title model))
                                      (annotated-results (and decorated
                                                              (propertize decorated
                                                                          :source source
                                                                          :title title
                                                                          :url url
                                                                          :model model
                                                                          :search-url search-url
                                                                          :query query))))
                                 (when (and annotated-results (functionp callback))
                                   (funcall callback (list annotated-results)))
                                 (list annotated-results))))))

#+end_src
**** define sources
#+begin_src emacs-lisp

(consult-omni-define-source "chatGPT"
                           :narrow-char ?a
                           :type 'dynamic
                           :require-match t
                           :face 'consult-omni-ai-title-face
                           :request #'consult-omni--chatgpt-fetch-results
                           :preview-key consult-omni-preview-key
                           :on-preview #'consult-omni--chatgpt-preview
                           :on-return #'identity
                           :on-callback #'consult-omni--chatgpt-preview
                           :search-hist 'consult-omni--search-history
                           :select-hist 'consult-omni--selection-history
                           :enabled (lambda () (bound-and-true-p consult-omni-openai-api-key))
                           :group #'consult-omni--group-function
                           :sort t
                           :static 'both
                           :annotate nil
                           )


#+end_src
**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-chatgpt' module

(provide 'consult-omni-chatgpt)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-chatgpt)
;;; consult-omni-chatgpt.el ends here
#+end_src


*** consult-line-multi
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-line-multi.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-omni-line-multi.el --- Search Lines in All Buffers  -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: ((emacs "28.1") (consult "1.4") (consult-omni "0.1"))
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:

;;; Code:

(require 'consult)
(require 'consult-omni)
#+end_src
**** helper functions
***** get candidates
#+begin_src emacs-lisp
(defun consult-omni--line-multi-candidates (input &optional buffers)
  "Wrapper around consult--line-multi-candidates for consult-omni."
  (let  ((buffers (or buffers (consult--buffer-query :directory (consult--normalize-directory default-directory) :sort 'alpha-current))))
    (consult--line-multi-candidates buffers input)))
#+end_src
***** preview
#+begin_src emacs-lisp

(defun consult-omni--line-multi-preview (cand)
"Preview function for consult-omni-line-multi."
  (let* ((marker (car (get-text-property 0 :marker cand)))
         (query (get-text-property 0 :query cand)))
    (consult--jump marker)
       ))

#+end_src
***** format
#+begin_src emacs-lisp
(cl-defun consult-omni--line-multi-format-candidate (&rest args &key source query marker title face &allow-other-keys)
  "Formats the cnaiddates of `consult-omni-line-multi'.

SOURCE is the name to use (e.g. “Line MUlti”)

QUERY is the query input from the user

MARKER is the marker pointing to results of line multi search

TITLE is the title of the candidate (e.g. line text)

FACE is the face to apply to TITLE"
  (let* ((frame-width-percent (floor (* (frame-width) 0.1)))
         (source (if (stringp source) (propertize source 'face 'consult-omni-source-type-face)))
         (marker (car marker))
         (buff (marker-buffer marker))
         (pos (marker-position marker))
         (buff (and buff (propertize (format "%s" buff) 'face 'consult-omni-domain-face)))
         (pos (and pos (propertize (format "%s" pos) 'face 'consult-omni-path-face)))
         (match-str (if (stringp query) (consult--split-escaped (car (consult--command-split query))) nil))
         (face (or (consult-omni--get-source-prop source :face) face 'consult-omni-default-face))
         (title-str (propertize title 'face face))
         (title-str (consult-omni--set-string-width title-str (* 6 frame-width-percent)))
         (str (concat title-str
                      (when buff (concat "\t" buff))
                      (when pos (concat "\s\s" pos ))
                      (when source (concat "\t" source))))
         )
    (if consult-omni-highlight-matches
        (cond
         ((listp match-str)
          (mapcar (lambda (match) (setq str (consult-omni--highlight-match match str t))) match-str))
         ((stringp match-str)
          (setq str (consult-omni--highlight-match match-str str t)))))
    str))
#+end_src

**** items
#+begin_src emacs-lisp

(cl-defun consult-omni--line-multi-fetch-results (input &rest args &key callback &allow-other-keys)
  "Fetches search results for INPUT from `consult-line-multi'."
(unless (functionp 'consult-omni--line-multi-candidates)
  (error "consult-omni: consult-omni-line-multi not available. Make sure `consult' is loaded properly"))
(pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (seq-difference args (list :callback callback))))
               (opts (car-safe opts))
               (items (consult-omni--line-multi-candidates query))
               (annotated-results (mapcar (lambda (item)
                                            (let* ((source "buffers text search")
                                                   (marker  (consult--get-location item))
                                                   (title (substring-no-properties item 0 -1))
                                                   (decorated (consult-omni--line-multi-format-candidate :source source :query query :marker marker :title title)))
                                           (propertize decorated
                                                       :source source
                                                       :title title
                                                       :url nil
                                                       :marker marker
                                                       :query query
                                                       ))) items)))
    annotated-results))
#+end_src


**** define source
#+begin_src emacs-lisp

(consult-omni-define-source "buffers text search"
                           :narrow-char ?s
                           :type 'sync
                           :require-match t
                           :category 'consult-location
                           :face 'default
                           :request #'consult-omni--line-multi-fetch-results
                           :preview-key consult-preview-key
                           :search-hist 'consult-omni--search-history
                           :select-hist 'consult-omni--selection-history
                           :on-preview #'consult-omni--line-multi-preview
                           :on-return #'identity
                           :on-callback #'consult-omni--line-multi-preview
                           :enabled (lambda () (fboundp 'consult-omni--line-multi-candidates))
                           :group #'consult-omni--group-function
                           :sort t
                           :static 'both
                           :annotate nil
                           )
#+end_src
**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-line-multi' module

(provide 'consult-omni-line-multi)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-line-multi)
;;; consult-omni-line-multi.el ends here
#+end_src


*** consult-buffer
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-buffer.el
:END:
**** header

#+begin_src emacs-lisp
;;; consult-omni-buffer.el --- Consulting Buffers -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: ((emacs "28.1") (consult "1.4") (consult-omni "0.1"))
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:

;;; Code:

(require 'consult-omni)
#+end_src
**** helper functions
***** preview
#+begin_src emacs-lisp
(defun consult-omni--consult-buffer-preview (cand)
  "Preview function for `consult-omni--buffer'."
  (if cand
      (let* ((title (get-text-property 0 :title cand)))
        (when-let ((buff (get-buffer title)))
          (consult--buffer-action buff))
        )))
#+end_src
**** define source
#+begin_src emacs-lisp
;; make consult-omni sources from `consult-buffer-sources'
(cl-loop for source in consult-buffer-sources
         do (if (symbolp source) (consult-omni--make-source-from-consult-source source
                                              :type 'sync
                                              :on-preview #'consult-omni--consult-buffer-preview
                                              :on-return #'identity
                                              :on-callback #'consult--buffer-action
                                              :search-hist 'consult-omni--search-history
                                              :select-hist 'consult-omni--selection-history
                                              :static 'both
                                              :preview-key 'consult-omni-preview-key
                                              :group #'consult-omni--group-function
                                              )))
#+end_src
**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-buffer' module

(provide 'consult-omni-buffer)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-buffer)
;;; consult-omni-buffer.el ends here
#+end_src


*** consult-notes
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-consult-notes.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-omni-consult-notes.el --- Consulting Consult Notes -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: ((emacs "28.1") (consult "1.4") (consult-omni "0.1") (consult-notes "0.7"))
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:

;;; Code:

(require 'consult-omni)
(require 'consult-notes nil t)
#+end_src
**** helper functions
***** preview
#+begin_src emacs-lisp
(defun consult-omni--org-roam-note-preview (cand)
  "Preview function for org-roam files."
  (if cand
      (let* ((title (get-text-property 0 :title cand))
             (node (org-roam-node-from-title-or-alias title)))
        (if (org-roam-node-p node)
            (consult--file-action (org-roam-node-file node))
          ))))

(defun consult-omni--org-headings-preview (cand)
  "Preview function for org headings."
  (if cand
      (let* ((title (get-text-property 0 :title cand))
             (marker (get-text-property 0 'consult--candidate title)))
        (if marker
            (consult--jump marker)))))
#+end_src

***** callback
#+begin_src emacs-lisp
(defun consult-omni--org-roam-note-callback (cand &rest args)
  "Callback function for org-roam files."
  (let* ((title (get-text-property 0 :title cand))
         (node (org-roam-node-from-title-or-alias title)))
    (org-roam-node-open node)))

(defun consult-omni--org-headings-callback (cand &rest args)
  "Callback function for org headings."
  (if cand
      (let* ((title (get-text-property 0 :title cand))
             (marker (get-text-property 0 'consult--candidate title)))
        (if marker
           (let* ((buff (marker-buffer marker))
                 (pos (marker-position marker)))
             (if buff (with-current-buffer buff
               (if pos (goto-char pos))
               (funcall consult--buffer-display buff)
               (recenter nil t)
               )))
             ))))
#+end_src

**** define source
***** consult-notes-org-headings
#+begin_src emacs-lisp
;; make consult-omni sources from consult-notes sources
(when consult-notes-org-headings-mode
  (consult-omni--make-source-from-consult-source 'consult-notes-org-headings--source
                                                :category 'file
                                                :type 'sync
                                                :face 'consult-omni-notes-title-face
                                                :search-hist 'consult-omni--search-history
                                                :select-hist 'consult-omni--selection-history
                                                :on-preview #'consult-omni--org-headings-preview
                                                :on-return #'identity
                                                :on-callback #'consult-omni--org-headings-callback
                                                :search-hist 'consult-omni--search-history
                                                :select-hist 'consult-omni--selection-history
                                                :preview-key 'consult-preview-key
                                                :group #'consult-omni--group-function
                                                :enabled (lambda () consult-notes-org-headings-mode)
                                                :static 'both
                                                ))
#+end_src

***** consult-notes-org-roam
#+begin_src emacs-lisp
(when consult-notes-org-roam-mode
  (cl-loop for source in '(consult-notes-org-roam--refs consult-notes-org-roam--nodes)
           do (consult-omni--make-source-from-consult-source source
                                                            :category 'file
                                                            :type 'sync
                                                            :face 'consult-omni-notes-title-face
                                                            :search-hist 'consult-omni--search-history
                                                            :select-hist 'consult-omni--selection-history
                                                            :on-preview #'consult-omni--org-roam-note-preview
                                                            :on-return #'identity
                                                            :on-callback #'consult-omni--org-roam-note-callback

                                                            :preview-key 'consult-preview-key
                                                            :static 'both
                                                            :group #'consult-omni--group-function
                                                            :enabled (lambda () consult-notes-org-roam-mode)
                                                            :annotate nil
                                                            )))
#+end_src

**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-consult-notes' module

(provide 'consult-omni-consult-notes)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-consult-notes)
;;; consult-omni-consult-notes.el ends here
#+end_src



*** consult-gh
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-gh.el
:END:
**** header

#+begin_src emacs-lisp
;;; consult-omni-gh.el --- Consulting Github Client -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: ((emacs "28.1") (consult "1.4") (consult-omni "0.1") (consult-gh "1.0.0"))
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:

;;; Code:

(require 'consult-omni)
(require 'consult-gh)
#+end_src
**** helper functions

***** preview
#+begin_src emacs-lisp
(defun consult-omni--gh-preview (cand)
  "Preview for github repo candidates"
  (when-let ((info (text-properties-at 0 (cdr (get-text-property 0 'multi-category cand))))
             (repo (plist-get info :repo))
             (query (plist-get info :query))
             (match-str (consult--build-args query))
             (buffer (get-buffer-create consult-gh-preview-buffer-name)))
    (add-to-list 'consult-gh--preview-buffers-list buffer)
    (consult-gh--repo-view (format "%s" repo) buffer)
    (with-current-buffer buffer
      (if consult-gh-highlight-matches
          (cond
           ((listp match-str)
            (mapcar (lambda (item)
                      (highlight-regexp item 'consult-gh-preview-match-face)) match-str))
           ((stringp match-str)
            (highlight-regexp match-str 'consult-gh-preview-match-face))
           )))
    (funcall (consult--buffer-preview) 'preview
             buffer
             )
    ))
#+end_src
***** callback
#+begin_src emacs-lisp
(defun consult-omni--gh-callback (cand)
  "Callback for github repo candidates."
  (funcall consult-gh-repo-action (cons cand (text-properties-at 0 (cdr (get-text-property 0 'multi-category cand))))))

#+end_src
**** items
#+begin_src emacs-lisp
(cl-defun consult-omni--gh-search-repos-builder (input &rest args &key callback &allow-other-keys)
  "makes builder command line args for “GitHub CLI”.
"
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (seq-difference args (list :callback callback))))
               (opts (car-safe opts))
               (count (plist-get opts :count))
               (count (or (and count (integerp (read count)) (string-to-number count))
                          consult-omni-default-count))
               (cmd (consult--build-args '("gh" "search" "repos")))
               (cmd-opts (list "--limit" (format "%s" count)))
               (`(,re . ,hl) (funcall consult--regexp-compiler query 'basic t)))
      (when re
        (cons (append cmd
                      (list (string-join re " "))
                      cmd-opts)
              hl))))
#+end_src
**** define source
#+begin_src emacs-lisp
(consult-omni-define-source "GitHub"
                           :narrow-char ?h
                           :type 'async
                           :require-match nil
                           :category 'consult-gh-repos
                           :face 'consult-omni-engine-title-face
                           :request #'consult-omni--gh-search-repos-builder
                           :on-preview #'consult-omni--gh-preview
                           :on-return #'identity
                           :on-callback #'consult-omni--gh-callback
                           :preview-key consult-omni-preview-key
                           :search-hist 'consult-omni--search-history
                           :select-hist 'consult-omni--selection-history
                           :group #'consult-omni--group-function
                           :sort t
                           :static 'both
                           :transform (lambda (items &optional query) (mapcar (lambda (string)
                                                                (consult-gh--repo-format string (or query "") t)) items))
                           :enabled (lambda () (if (and (executable-find "gh")
                                                   (fboundp 'consult-gh-search-repos))
                                                   t nil))
                           :annotate nil
                           )
#+end_src

**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-gh' module

(provide 'consult-omni-gh)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-gh)
;;; consult-omni-gh.el ends here
#+end_src


*** consult-grep
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-grep.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-omni-grep.el --- Consulting Grep Command -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: ((emacs "28.1") (consult "1.4") (consult-omni "0.1"))
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:

;;; Code:

(require 'consult-omni)
#+end_src
**** helper functions
***** grep-builder
#+begin_src emacs-lisp
(defun consult-omni--grep-make-builder (make-builder &optional dir)
  "General builders for grep and similar process.
"
(pcase-let* ((`(_ ,paths ,dir) (consult--directory-prompt "" dir))
             (paths (if dir
                        (mapcar (lambda (path) (file-truename (concat dir path))) paths)
                      paths))
             )
(funcall make-builder paths)
))
#+end_src



***** transform
#+begin_src emacs-lisp
(defun consult-omni--grep-transform (candidates &optional query)
  "Formats candidates pf `consult-omni-grep'.
"
  (let* ((frame-width-percent (floor (* (frame-width) 0.1)))
         (file "")
         (file-len 0)
         (file-str "")
         result)
    (save-match-data
      (dolist (str candidates)
        (when (and (string-match consult--grep-match-regexp str)
                   ;; Filter out empty context lines
                   (or (/= (aref str (match-beginning 3)) ?-)
                       (/= (match-end 0) (length str))))
          ;; We share the file name across candidates to reduce
          ;; the amount of allocated memory.
          (unless (and (= file-len (- (match-end 1) (match-beginning 1)))
                       (eq t (compare-strings
                              file 0 file-len
                              str (match-beginning 1) (match-end 1) nil)))
             (setq file (or (and (buffer-file-name)
                           (file-relative-name (match-string 1 str) (file-name-directory (buffer-file-name))))
                          (file-relative-name (match-string 1 str))))

                  (when (and file (stringp file) (> file-len (* frame-width-percent 2)))
                    (setq file (consult-omni--set-string-width file (* frame-width-percent 2) (* frame-width-percent 1))))
                  (setq file-len (length file))
                  )
            (let* ((line (propertize (match-string 2 str) 'face 'consult-line-number))
                   (ctx (= (aref str (match-beginning 3)) ?-))
                   (sep (if ctx "-" ":"))
                   (content (substring str (match-end 0)))
                   (line-len (length line)))
              (when (length> content consult-grep-max-columns)
                ;; (setq content (substring content 0 consult-grep-max-columns))
                (setq content  (consult-omni--set-string-width content consult-grep-max-columns))
                )
              (setq str (concat file sep line sep content))
              ;; Store file name in order to avoid allocations in `consult--prefix-group'
              (add-text-properties 0 file-len `(face consult-file consult--prefix-group ,file) str)
              ;; (put-text-property (1+ file-len) (+ 1 file-len line-len) 'face 'consult-line-number str)
              (when ctx
                (add-face-text-property (+ 2 file-len line-len) (length str) 'consult-grep-context 'append str))
              (push (propertize str :source "grep" :title query) result)))))
      result))
#+end_src



***** preview
#+begin_src emacs-lisp

(defun consult-omni--grep-preview (cand)
  "Grep preview function."
(funcall  (consult--jump-state) 'preview (consult--grep-position (cdr (get-text-property 0 'multi-category cand))))
  )

#+end_src

***** callback
#+begin_src emacs-lisp
(defun consult-omni--grep-callback (cand)
  "Grep callback function."
(funcall  (consult--jump-state) 'return (consult--grep-position (cdr (get-text-property 0 'multi-category cand))))
  )
#+end_src

**** items
#+begin_src emacs-lisp
(cl-defun consult-omni--grep-builder (input &rest args &key callback &allow-other-keys)
  "Makes builder command line args for “grep”.
"
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (seq-difference args (list :callback callback))))
               (opts (car-safe opts))
               (count (plist-get opts :count))
               (dir (plist-get opts :dir))
               (dir (if dir (file-truename (format "%s" dir))))
               (count (or (and count (integerp (read count)) (string-to-number count))
                          consult-omni-default-count))
               (default-directory (or dir default-directory))
               )
   (funcall (consult-omni--grep-make-builder #'consult--grep-make-builder dir) query)
            ))
#+end_src


**** define source
#+begin_src emacs-lisp
(consult-omni-define-source "grep"
                           :narrow-char ?r
                           :type 'async
                           :require-match t
                           :face 'consult-omni-engine-title-face
                           :request #'consult-omni--grep-builder
                           :transform #'consult-omni--grep-transform
                           :on-preview #'consult-omni--grep-preview
                           :on-return #'identity
                           :on-callback #'consult-omni--grep-callback
                           :preview-key consult-omni-preview-key
                           :search-hist 'consult-omni--search-history
                           :select-hist 'consult-omni--selection-history
                           :group #'consult-omni--group-function
                           :sort t
                           :static 'both
                           :transform #'consult-omni--ripgrep-transform
                           :enabled (lambda () (if (and (executable-find "grep")
                                                   (fboundp 'consult-grep))
                                                   t nil))
                           :annotate nil
                           )
#+end_src

**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-grep' module

(provide 'consult-omni-grep)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-grep)
;;; consult-omni-grep.el ends here
#+end_src


*** notes
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-notes.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-omni-notes.el --- Consulting Note Files -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: ((emacs "28.1") (consult "1.4") (consult-omni "0.1"))
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:

;;; Code:

(require 'consult-omni)
(require 'consult-omni-grep)
#+end_src

**** custom variables
#+begin_src emacs-lisp
(defcustom consult-omni-notes-files (apply #'append
                                     (when (bound-and-true-p consult-notes-file-dir-sources)
                                     ;; dir sources
                                     (apply #'append (mapcar #'cddr consult-notes-file-dir-sources)))
                                     ;; org roam
                                     (when (bound-and-true-p org-roam-directory)
                                       (list (expand-file-name org-roam-directory)))
                                     ;; denote
                                     (when (bound-and-true-p denote-directory)
                                       (list (expand-file-name denote-directory)))
                                     ;; org agenda files
                                     (when (bound-and-true-p consult-notes-org-headings-mode)
                                       (list (mapcar #'expand-file-name consult-notes-org-headings-files))))
"List of all note files for consult-omni-notes."
:type '(repeat :tag "list of files" string))

(defcustom consult-omni-notes-use-rg t
"whether to use ripgrep when searching ntoes?"
:type 'boolean)

#+end_src

**** helper functions
***** transform
#+begin_src emacs-lisp
(defun consult-omni--notes-transform (candidates &optional query)
  "Formats `consult-omni-notes' candidates.
"
(let* ((frame-width-percent (floor (* (frame-width) 0.1)))
      (file "")
      (file-len 0)
      (file-str "")
      result)
          (save-match-data
            (dolist (str candidates)
              (when (and (string-match consult--grep-match-regexp str)
                         ;; Filter out empty context lines
                         (or (/= (aref str (match-beginning 3)) ?-)
                             (/= (match-end 0) (length str))))
                ;; We share the file name across candidates to reduce
                ;; the amount of allocated memory.
                (unless (and (= file-len (- (match-end 1) (match-beginning 1)))
                             (eq t (compare-strings
                                    file 0 file-len
                                    str (match-beginning 1) (match-end 1) nil)))
                  (setq file (match-string 1 str))
                  ;; (setq file (file-truename file))
                  ;; (if (> file-len (* frame-width-percent 2))
                  ;;   (setq file-str (consult-omni--set-string-width file (* frame-width-percent 2) (* frame-width-percent 1)))
                  ;;   (setq file-str file))
                  ;; (when (> file-len (* frame-width-percent 2))
                  ;;   (setq file (consult-omni--set-string-width file (* frame-width-percent 2) (* frame-width-percent 1))
                  ;;                          ))

                  ;; (propertize file-str 'face 'consult-file 'consult--prefix-group file)
                  (setq file-len (length file))
)
                (let* ((line (propertize (match-string 2 str) 'face 'consult-line-number))
                       (ctx (= (aref str (match-beginning 3)) ?-))
                       (sep (if ctx "-" ":"))
                       (content (substring str (match-end 0)))
                       (line-len (length line)))
                  (when (length> content consult-grep-max-columns)
                    ;; (setq content (substring content 0 consult-grep-max-columns))
                    (setq content  (consult-omni--set-string-width content consult-grep-max-columns))
                    )
                  (setq str (concat file sep line sep content))

                  ;; (setq str (concat content sep line sep (propertize (file-name-nondirectory file) 'face 'consult-file 'consult--prefix-group file)))
                  ;; Store file name in order to avoid allocations in `consult--prefix-group'
                  (add-text-properties 0 file-len `(face consult-file consult--prefix-group ,file) str)
                  (put-text-property (1+ file-len) (+ 1 file-len line-len) 'face 'consult-line-number str)
                  ;; (when ctx
                  ;;   (add-face-text-property (+ 2 file-len line-len) (length str) 'consult-grep-context 'append str))
                  (push (propertize str :source "Notes Search" :title query :file file) result)))))
          result))
#+end_src

**** items
#+begin_src emacs-lisp
(cl-defun consult-omni--notes-builder (input &rest args &key callback &allow-other-keys)
  "Makes builder command line args for `consult-omni-notes'.
"
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input args))
               (opts (car-safe opts))
               (count (plist-get opts :count))
               (dir (plist-get opts :dir))
               (dir (if dir (file-truename (format "%s" dir))))
               (dir (or dir consult-omni-notes-files))
               (count (or (and count (integerp (read count)) (string-to-number count))
                          consult-omni-default-count))
               )
   (funcall (consult-omni--grep-make-builder (if (and consult-omni-notes-use-rg (executable-find "rg")) #'consult--ripgrep-make-builder #'consult--grep-make-builder) dir) query)
            ))
#+end_src


**** define source
#+begin_src emacs-lisp
(consult-omni-define-source "Notes Search"
                           :narrow-char ?n
                           :type 'async
                           :require-match nil
                           :face 'consult-omni-engine-title-face
                           :request #'consult-omni--notes-builder
                           :transform #'consult-omni--notes-transform
                           :on-preview #'consult-omni--grep-preview
                           :on-return #'identity
                           :on-callback #'consult-omni--grep-callback
                           :preview-key 'any
                           :search-hist 'consult-omni--search-history
                           :select-hist 'consult-omni--selection-history
                           :group #'consult-omni--group-function
                           ;;:group #'consult--prefix-group
                           :sort t
                           :static 'both
                           :annotate nil
                           )
#+end_src


**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-notes' module

(provide 'consult-omni-notes)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-notes)
;;; consult-omni-notes.el ends here
#+end_src


*** consult-find
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-find.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-omni-find.el --- Consulting Find Command -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: ((emacs "28.1") (consult "1.4") (consult-omni "0.1"))
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:

;;; Code:

(require 'consult-omni)
#+end_src
**** custom variables
#+begin_src emacs-lisp
(defcustom consult-omni-find-show-hidden-files t
  "Whether to show hidden files in `consult-omni-find'."
  :type 'boolean)

(defcustom consult-omni-find-args  "find ."
  "Command line arguments for find.

Similar to `consult-find-args' bur for consult-omni."
  :type '(choice string (repeat (choice string sexp))))


#+end_src
**** helper functions
***** transform
#+begin_src emacs-lisp
(defun consult-omni--find-transform (candidates &optional query)
  "Formats candidates of `consult-omni-find'.
"
  (mapcar (lambda (candidate)
           (string-trim (string-remove-prefix (file-truename default-directory) candidate)))
          candidates))
#+end_src
***** filter
#+begin_src emacs-lisp
(defun consult-omni--find-filter (candidates &optional query)
  "Filters for candidates of `consult-omni-find'.
"
  (seq-filter (lambda (candidate) (not (string-match "^find:.*$" candidate nil nil))) candidates))

#+end_src
***** preview
#+begin_src emacs-lisp

(defun consult-omni--find-preview (cand)
  "Grep preview function."
(funcall (consult--file-preview) 'preview cand))
#+end_src

***** callback
#+begin_src emacs-lisp
(defun consult-omni--find-callback (cand)
  "Find callback function."
  (consult--file-action cand)
  )
#+end_src

**** items
#+begin_src emacs-lisp
(cl-defun consult-omni--find-builder (input &rest args &key callback &allow-other-keys)
  "Makes builder command line args for “find”.
"
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (seq-difference args (list :callback callback))))
               (opts (car-safe opts))
               (count (plist-get opts :count))
               (hidden (if (plist-member opts :hidden) (plist-get opts :hidden) consult-omni-find-show-hidden-files))
               (ignore (plist-get opts :ignore))
               (ignore (if ignore (format "%s" ignore)))
               (dir (plist-get opts :dir))
               (dir (if dir (file-truename (format "%s" dir))))
               (count (or (and count (integerp (read count)) (string-to-number count))
                          consult-omni-default-count))
               (default-directory (or dir default-directory))
               (`(_ ,paths _) (consult--directory-prompt "" dir))
               (paths (if dir
                        (mapcar (lambda (path) (file-truename (concat dir path))) paths)
                      paths))
               (consult-find-args (concat consult-omni-find-args
                                          (if (not hidden) " -not -iwholename *./[a-z]*")
                                          (if ignore (concat " -not -iwholename *" ignore "*"))))
               )
   (funcall (consult--find-make-builder paths) query)
            ))
#+end_src

**** define source
#+begin_src emacs-lisp
(consult-omni-define-source "find"
                           :narrow-char ?f
                           :category 'file
                           :type 'async
                           :require-match t
                           :face 'consult-omni-engine-title-face
                           :request #'consult-omni--find-builder
                           :transform #'consult-omni--find-transform
                           :filter #'consult-omni--find-filter
                           :on-preview #'consult-omni--find-preview
                           :on-return #'identity
                           :on-callback #'consult-omni--find-callback
                           :preview-key consult-omni-preview-key
                           :search-hist 'consult-omni--search-history
                           :select-hist 'consult-omni--selection-history
                           :group #'consult-omni--group-function
                           :sort t
                           :static 'both
                           :enabled (lambda () (if (executable-find "find") t nil))
                           :annotate nil
                           )
#+end_src

**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-find' module

(provide 'consult-omni-find)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-find)
;;; consult-omni-find.el ends here
#+end_src


*** consult-locate
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-locate.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-omni-locate.el --- Consulting Locate Command -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: ((emacs "28.1") (consult "1.4") (consult-omni "0.1"))
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:

;;; Code:

(require 'consult-omni)
#+end_src

**** custom variables
#+begin_src emacs-lisp

(defcustom consult-omni-locate-limit consult-omni-default-count
  "Max number results for `consult-omni-locate'

This is passed to “-l” command line argument.
"
  :type 'integer)

(defcustom consult-omni-locate-args "locate -i"
"Command line arguments for locate.

Similar to `consult-locate-args' bur for consult-omni."
  :type '(choice string (repeat (choice string sexp))))

#+end_src
**** helper functions
***** preview
#+begin_src emacs-lisp

(defun consult-omni--locate-preview (cand)
  "Grep preview function."
(funcall (consult--file-preview) 'preview cand))
#+end_src

***** callback
#+begin_src emacs-lisp
(defun consult-omni--locate-callback (cand)
  "Find callback function."
  (consult--file-action cand)
  )
#+end_src

***** transform
#+begin_src emacs-lisp
(defun consult-omni--find-transform (candidates &optional query)
  "Formats candidates `consult-omni-find'.
"
  (mapcar (lambda (candidate)
           (string-remove-prefix (file-truename default-directory) candidate))
          candidates))
#+end_src



***** filter
#+begin_src emacs-lisp
(defun consult-omni--locate-filter (candidates &optional query)
  "Filter for candidates of `consult-omni-find'.
"
  (seq-filter (lambda (candidate) (not (string-match "^locate:.*$" candidate nil nil))) candidates))

#+end_src
**** items
#+begin_src emacs-lisp
(cl-defun consult-omni--locate-builder (input &rest args &key callback &allow-other-keys)
  "Makes builder command line args for “locate”.
"
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (seq-difference args (list :callback callback))))
               (opts (car-safe opts))
               (count (plist-get opts :count))
               (dir (plist-get opts :dir))
               (dir (if dir (file-truename (format "%s" dir))))
               (count (or (and (integerp count) count)
                          (and count (string-to-number (format "%s" count)))
                          consult-omni-locate-limit))
               (default-directory (or dir default-directory))
               (consult-locate-args (concat consult-omni-locate-args
                                            (if count (format " -l %s" count))))
               )

   (funcall #'consult--locate-builder query)
            ))
#+end_src

**** define source
#+begin_src emacs-lisp
(consult-omni-define-source "locate"
                           :narrow-char ?f
                           :category 'file
                           :type 'async
                           :require-match t
                           :face 'consult-omni-engine-title-face
                           :request #'consult-omni--locate-builder
                           ;; :transform nil
                           :filter #'consult-omni--locate-filter
                           :on-preview #'consult-omni--locate-preview
                           :on-return #'identity
                           :on-callback #'consult-omni--locate-callback
                           :preview-key consult-omni-preview-key
                           :search-hist 'consult-omni--search-history
                           :select-hist 'consult-omni--selection-history
                           :group #'consult-omni--group-function
                           :enabled (lambda () (if (executable-find "locate") t nil))
                           :sort t
                           :static 'both
                           :annotate nil
                           )
#+end_src

**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-locate' module

(provide 'consult-omni-locate)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-locate)
;;; consult-omni-locate.el ends here
#+end_src



*** consult-mdfind
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-locate.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-omni-mdfind.el --- Consulting mdfind Command -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: ((emacs "28.1") (consult "1.4") (consult-omni "0.1"))
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:

;;; Code:

(require 'consult-omni)
#+end_src

**** custom variables
#+begin_src emacs-lisp

(defcustom consult-omni-mdfind-interpret t
  "Whether to toggle -interpret arg in mdfind.
See mdfind documents (e.g. “man mdfind”) for more details.
"
  :type 'boolean)

(defcustom consult-omni-mdfind-args "mdfind"
"Command line arguments for mdfind.

Similar to other command line args for consult but for mdfind.
See `consult-locate-args' for example."
  :type '(choice string (repeat (choice string sexp))))
#+end_src

**** helper functions
***** preview
#+begin_src emacs-lisp

(defun consult-omni--mdfind-preview (cand)
  "Mdfind preview function."
(funcall (consult--file-preview) 'preview cand))
#+end_src

***** callback
#+begin_src emacs-lisp
(defun consult-omni--mdfind-callback (cand)
  "Mdfind callback function."
  (consult--file-action cand)
  )
#+end_src

***** transform
#+begin_src emacs-lisp
(defun consult-omni--find-transform (candidates &optional query)
  "Formats candidate sof `consult-omni-mdfind'.
"
  (mapcar (lambda (candidate)
           (string-remove-prefix (file-truename default-directory) candidate))
          candidates))
#+end_src



***** filter
#+begin_src emacs-lisp
(defun consult-omni--mdfind-filter (candidates &optional query)
  "Filter for candidates of `consult-omni-mdfind'.
"
)

#+end_src
**** items
#+begin_src emacs-lisp
(cl-defun consult-omni--mdfind-builder (input &rest args &key callback &allow-other-keys)
  "Makes builder command line args for “mdfind”.
"
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (seq-difference args (list :callback callback))))
               (opts (car-safe opts))
               (count (plist-get opts :count))
               (dir (plist-get opts :dir))
               (dir (if dir (file-truename (format "%s" dir))))
               (count (or (and count (integerp (read count)) (string-to-number count))
                          consult-omni-default-count))
               (default-directory (or dir default-directory))
               (consult-locate-args (concat consult-omni-mdfind-args
                                            (if consult-omni-mdfind-interpret " -interpret")
(if dir (format " -onlyin %s" dir)))))
   (funcall #'consult--locate-builder query)
            ))
#+end_src

**** define source
#+begin_src emacs-lisp
(consult-omni-define-source "mdfind"
                           :narrow-char ?f
                           :category 'file
                           :type 'async
                           :require-match t
                           :face 'consult-omni-engine-title-face
                           :request #'consult-omni--mdfind-builder
                           :on-preview #'consult-omni--mdfind-preview
                           :on-return #'identity
                           :on-callback #'consult-omni--mdfind-callback
                           :preview-key consult-omni-preview-key
                           :search-hist 'consult-omni--search-history
                           :select-hist 'consult-omni--selection-history
                           :group #'consult-omni--group-function
                           :enabled (lambda () (if (executable-find "mdfind") t nil))
                           :sort t
                           :static 'both
                           :annotate nil
                           )
#+end_src

**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-mdfind' module

(provide 'consult-omni-mdfind)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-mdfind)
;;; consult-omni-mdfind.el ends here
#+end_src



*** consult-mu
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-mu4e.el
:END:
**** header

#+begin_src emacs-lisp
;;; consult-omni-mu4e.el --- Consulting Mu4e -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: ((emacs "28.1") (consult "1.4") (consult-mu "1.0") (consult-omni "0.1"))
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:

;;; Code:

(require 'consult-omni)
(require 'consult-mu)
#+end_src
**** helper functions
***** format
#+begin_src emacs-lisp
(defun consult-omni-mu--format-candidate (cand highlight)
  "Formats candidates for `consult-omni-mu4e'
"

  (let* ((string (car cand))
         (info (cadr cand))
         (msg (plist-get info :msg))
         (query (plist-get info :query))
         (match-str (if (stringp query) (consult--split-escaped (car (consult--command-split query))) nil))
         (headers-template (consult-mu--headers-template))
         (str (if headers-template
                 (consult-mu--expand-headers-template msg headers-template)
                  string)
         )
         (str (propertize str :msg msg :query query :type :dynamic :source "mu4e" :title string))
         )
         (if (and consult-mu-highlight-matches highlight)
                     (cond
                      ((listp match-str)
                       (mapcar (lambda (match) (setq str (consult-mu--highlight-match match str t))) match-str))
                      ((stringp match-str)
                       (setq str (consult-mu--highlight-match match-str str t))))
           str)
(when msg
  (cons str (list :msg msg :query query :type :dynamic)))))

#+end_src

***** preview

#+begin_src emacs-lisp
(defun consult-omni--mu-preview (cand)
  "Preview for mu4e candidates"
  (when-let* ((info (text-properties-at 0 (cdr (get-text-property 0 'multi-category cand))))
              (msg (plist-get info :msg))
              (query (plist-get info :query))
              (msgid (substring-no-properties (plist-get msg :message-id)))
              (match-str (car (consult--command-split query)))
              (match-str (car (consult--command-split query)))
              (mu4e-headers-buffer-name consult-mu-headers-buffer-name)
              (buffer consult-mu-view-buffer-name))
    (add-to-list 'consult-mu--view-buffers-list buffer)
    (funcall (consult--buffer-preview) 'preview
             (consult-mu--view msg t consult-mu-mark-previewed-as-read match-str)
             )
    (with-current-buffer consult-mu-view-buffer-name
      (unless (one-window-p) (delete-other-windows))
      ))
  )
#+end_src
***** return
#+begin_src emacs-lisp
(defun consult-omni--mu-return (cand)
  "Return function for mu4e candidates."
(save-mark-and-excursion
  (consult-mu--execute-all-marks)
  )
(setq consult-mu--override-group nil)
cand
)
#+end_src
***** callback
#+begin_src emacs-lisp
(defun consult-omni--mu-callback (cand)
  "Callback function for mu4e candidates."
  (let* ((info (text-properties-at 0 (cdr (get-text-property 0 'multi-category cand))))
         (msg (plist-get info :msg))
         (query (plist-get info :query))
         (match-str (car (consult--command-split query)))
         )
    (consult-mu--view msg nil consult-mu-mark-viewed-as-read match-str)
    (consult-mu-overlays-toggle consult-mu-view-buffer-name)
    )
)
#+end_src
**** items
#+begin_src emacs-lisp
(cl-defun consult-omni--mu-fetch-results (input &rest args &key callback &allow-other-keys)
  "Makes builder command line args for “mu4e”.
"
  (save-mark-and-excursion
  (consult-mu--execute-all-marks)
  )
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (seq-difference args (list :callback callback))))
               (opts (car-safe opts))
               (count (plist-get opts :count))
               (count (or (and count (integerp (read count)) (string-to-number count))
                          consult-omni-default-count))
               (mu-input (format "%s -- --maxnum %s" query count))
               (messages)
               )
    (consult-mu--update-headers mu-input nil nil :dynamic)
    (with-current-buffer consult-mu-headers-buffer-name
      (goto-char (point-min))
     (setq messages (remove nil
              (cl-loop until (eobp)
                       collect (let ((msg (ignore-errors (mu4e-message-at-point))))
                                 (consult-omni-mu--format-candidate `(,(buffer-substring (point) (point-at-eol)) (:msg ,(ignore-errors (mu4e-message-at-point)) :query ,input)) t))
                 do (forward-line 1)))
           ))
    (when (and messages callback)
      (funcall callback messages))))
#+end_src
**** define source
#+begin_src emacs-lisp
(consult-omni-define-source "mu4e"
                           :narrow-char ?m
                           :type 'dynamic
                           :require-match nil
                           :category 'consult-mu-messages
                           :face 'consult-omni-engine-title-face
                           :request #'consult-omni--mu-fetch-results
                           :lookup #'consult-mu--lookup
                           :on-preview #'consult-omni--mu-preview
                           :on-return #'consult-omni--mu-return
                           :on-callback #'consult-omni--mu-callback
                           :preview-key consult-omni-preview-key
                           :search-hist 'consult-omni--search-history
                           :select-hist 'consult-omni--selection-history
                           :enabled (lambda () (if (and (executable-find "mu")
                                                   (fboundp 'consult-mu))
                                                   t nil))
                           :group #'consult-omni--group-function
                           :sort t
                           :static 'both
                           :annotate nil
                           )
#+end_src

**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-mu4e' module

(provide 'consult-omni-mu4e)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-gh)
;;; consult-omni-mu4e.el ends here
#+end_src



*** consult-ripgrep
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-ripgrep.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-omni-ripgrep.el --- Consulting Ripgrep Command -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: ((emacs "28.1") (consult "1.4") (consult-omni "0.1"))
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:

;;; Code:

(require 'consult-omni)
(require 'consult-omni-grep)
#+end_src
**** helper functions
***** transform
#+begin_src emacs-lisp
(defun consult-omni--ripgrep-transform (candidates &optional query)
  "Formats candidates of `consult-omni-ripgrep'.
"
(let* ((frame-width-percent (floor (* (frame-width) 0.1)))
      (file "")
      (file-len 0)
      (file-str "")
      result)
          (save-match-data
            (dolist (str candidates)
              (when (and (string-match consult--grep-match-regexp str)
                         ;; Filter out empty context lines
                         (or (/= (aref str (match-beginning 3)) ?-)
                             (/= (match-end 0) (length str))))
                ;; We share the file name across candidates to reduce
                ;; the amount of allocated memory.
                (unless (and (= file-len (- (match-end 1) (match-beginning 1)))
                             (eq t (compare-strings
                                    file 0 file-len
                                    str (match-beginning 1) (match-end 1) nil)))
                  (setq file (or (and (buffer-file-name)
                           (file-relative-name (match-string 1 str) (file-name-directory (buffer-file-name))))
                          (file-relative-name (match-string 1 str))))

                  (when (and file (stringp file) (> file-len (* frame-width-percent 2)))
                    (setq file (consult-omni--set-string-width file (* frame-width-percent 2) (* frame-width-percent 1))))
                  (setq file-len (length file))

                  )
                (let* ((line (propertize (match-string 2 str) 'face 'consult-line-number))
                       (ctx (= (aref str (match-beginning 3)) ?-))
                       (sep (if ctx "-" ":"))
                       (content (substring str (match-end 0)))
                       (line-len (length line)))
                  (when (length> content consult-grep-max-columns)
                    ;; (setq content (substring content 0 consult-grep-max-columns))
                    (setq content  (consult-omni--set-string-width content consult-grep-max-columns))
                    )
                  (setq str (concat file sep line sep content))
                  ;; Store file name in order to avoid allocations in `consult--prefix-group'
                  (add-text-properties 0 file-len `(face consult-file consult--prefix-group ,file) str)
                  ;; (put-text-property (1+ file-len) (+ 1 file-len line-len) 'face 'consult-line-number str)
                  (when ctx
                    (add-face-text-property (+ 2 file-len line-len) (length str) 'consult-grep-context 'append str))
                  (push (propertize str :source "ripgrep" :title query) result)))))
          result))
#+end_src

#+begin_src emacs-lisp
(file-relative-name "/Users/armin/projects/consult-omni/README.org" (buffer-file-name))
#+end_src



**** items
#+begin_src emacs-lisp
(cl-defun consult-omni--ripgrep-builder (input &rest args &key callback &allow-other-keys)
  "makes builder command line args for “ripgrep”.
"
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (seq-difference args (list :callback callback))))
               (opts (car-safe opts))
               (count (plist-get opts :count))
               (dir (plist-get opts :dir))
               (dir (if dir (file-truename (format "%s" dir))))
               (count (or (and count (integerp (read count)) (string-to-number count))
                          consult-omni-default-count))
               (default-directory (or dir default-directory))
               )
   (funcall (consult-omni--grep-make-builder #'consult--ripgrep-make-builder dir) query)
            ))
#+end_src


**** define source
#+begin_src emacs-lisp
(consult-omni-define-source "ripgrep"
                           :narrow-char ?r
                           :type 'async
                           :require-match t
                           :face 'consult-omni-engine-title-face
                           :request #'consult-omni--ripgrep-builder
                           :transform #'consult-omni--ripgrep-transform
                           :on-preview #'consult-omni--grep-preview
                           :on-return #'identity
                           :on-callback #'consult-omni--grep-callback
                           :preview-key consult-omni-preview-key
                           :search-hist 'consult-omni--search-history
                           :select-hist 'consult-omni--selection-history
                           :group #'consult-omni--group-function
                           :enabled (lambda () (if (and (executable-find "rg")
                                                   (fboundp 'consult-ripgrep))
                                                   t nil))
                           :sort t
                           :static 'both
                           :transform #'consult-omni--ripgrep-transform
                           :annotate nil
                           )
#+end_src

**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-ripgrep' module

(provide 'consult-omni-ripgrep)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-ripgrep)
;;; consult-omni-ripgrep.el ends here
#+end_src


*** Doi.org
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-doi.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-omni-doi.el --- Consulting DOI.org -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: ((emacs "28.1") (consult "1.4") (consult-omni "0.1"))
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:

;;; Code:

(require 'consult-omni)
#+end_src
**** variables
***** others
#+begin_src emacs-lisp
(defvar consult-omni-doiorg-api-url "https://doi.org/api/handles/")

(defvar consult-omni-doiorg-search-url "https://doi.org/")

#+end_src
***** history variables
#+begin_src emacs-lisp
(defvar consult-omni--doi-search-history (list)
  "History variables for search terms when using
`consult-omni-doi' commands.")

(defvar consult-omni--doi-selection-history (list)
  "History variables for selected items when using
`consult-omni-doi' commands.")
#+end_src
**** helper functions
***** doi to url
#+begin_src emacs-lisp
(defun consult-omni--doi-to-url (doi)
  "Converts DOI value to target url"
  (let ((out))
    (let* ((doi (if doi (format "%s" doi)))
           (url (concat consult-omni-doiorg-api-url doi)))
       (consult-omni--fetch-url url consult-omni-http-retrieve-backend
                               :sync t
                               :encoding 'utf-8
                               :parser #'consult-omni--json-parse-buffer
                               :callback
                               (lambda (attrs)
                                 (let* ((raw-results (map-nested-elt attrs '("values")))
                                        (result (car-safe (remove nil (mapcar (lambda (item)
                                                                                     (if-let* ((type (gethash "type" item))                                                                                                        (link (if (equal type "URL") (map-nested-elt item '("data" "value")))))
                                                                                         link))
                                                                                   raw-results)))))
                                  result))))))


#+end_src
**** items
#+begin_src emacs-lisp

(cl-defun consult-omni--doiorg-fetch-results (input &rest args &key callback &allow-other-keys)
  "Fetch target url of DOI.
"
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (seq-difference args (list :callback callback))))
               (opts (car-safe opts))
               (source "doiorg")
               (url (consult-omni--doi-to-url query))
               (title (if url (format "%s" url) (format "%s - Not Found" query)))
               (search-url (concat consult-omni-doiorg-search-url query))
               (decorated (funcall consult-omni-default-format-candidate :source source :query query :url url :search-url search-url :title title))
               (annotated-results (propertize decorated
                                              :source source
                                              :title title
                                              :url url
                                              :search-url search-url
                                              :query query)))
    (when url
      (list annotated-results))
    ))

#+end_src
**** define source
#+begin_src emacs-lisp

(consult-omni-define-source "doiorg"
                           :narrow-char ?D
                           :type 'sync
                           :require-match t
                           :face 'link
                           :request #'consult-omni--doiorg-fetch-results
                           :preview-key consult-omni-preview-key
                           :search-hist 'consult-omni--doi-search-history
                           :select-hist 'consult-omni--doi-selection-history
                           :enabled (lambda () (bound-and-true-p consult-omni-doiorg-search-url))
                           :group #'consult-omni--group-function
                           :sort t
                           :static 'both
                           )
#+end_src
**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-doi' module

(provide 'consult-omni-doi)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-doi)
;;; consult-omni-doi.el ends here
#+end_src


*** DuckDuckGo
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-duckduckgo.el
:END:
**** header

#+begin_src emacs-lisp
;;; consult-omni-duckduckgo.el --- Consulting DuckDuckGo -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: ((emacs "28.1") (consult "1.4") (consult-omni "0.1"))
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:

;;; Code:

(require 'consult-omni)
#+end_src
**** variables
***** other
#+begin_src emacs-lisp
(defvar consult-omni-duckduckgo-api-url "http://api.duckduckgo.com/")

(defvar consult-omni-duckduckgo-search-url "https://duckduckgo.com/")

#+end_src
**** items
#+begin_src emacs-lisp
(cl-defun consult-omni--duckduckgoapi-fetch-results (input &rest args &key callback &allow-other-keys)
  "Fetch search results got INPUT from DuckDuckGo limited API.

See URL `https://duckduckgo.com/duckduckgo-help-pages/settings/params/'
for some limited documentation"
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input))
               (opts (car-safe opts))
               (count (plist-get opts :count))
               (page (plist-get opts :page))
               (extra-args (seq-difference (append opts args) '(:count count :page page)))
               (count (or (and count (integerp (read count)) (string-to-number count))
                          consult-omni-default-count))
               (page (or (and page (integerp (read page)) (string-to-number page))
                         consult-omni-default-page))
               (count (min count 10))
               (page (+ (* page count) 1))
               (params `(("q" . ,(replace-regexp-in-string " " "+" query))
                         ("format" . "json")))
               (headers `(("Accept" . "application/json"))))
    (consult-omni--fetch-url consult-omni-duckduckgo-api-url consult-omni-http-retrieve-backend
                            :encoding 'utf-8
                            :params params
                            :headers headers
                            :parser #'consult-omni--json-parse-buffer
                            :callback
                            (lambda (attrs)
                              (let* ((raw-results (gethash "RelatedTopics" attrs))
                                     (annotated-results
                                           (remove nil (mapcar (lambda (item)
                                                     (let*
                                                         ((source "DuckDuckGo API")
                                                          (url (gethash "FirstURL" item))
                                                          (title (gethash "Result" item))
                                                          (title (if (and title (stringp title) (string-match "<a href=.*>\\(?1:.*\\)</a>.*" title)) (match-string 1 title) nil))
                                                          (snippet (format "%s" (gethash "Text" item)))
                                                          (search-url (consult-omni--make-url-string consult-omni-duckduckgo-search-url params '("format")))
                                                          (decorated (if title (funcall consult-omni-default-format-candidate :source source :query query :url url :search-url search-url :title title :snippet snippet) nil)))
                                                       (if decorated (propertize decorated
                                                                   :source source
                                                                   :title title
                                                                   :url url
                                                                   :search-url search-url
                                                                   :query query
                                                                   ))))

                                                   raw-results))))
                                (when (and annotated-results (functionp callback))
                                  (funcall callback annotated-results))
                                annotated-results)))))

#+end_src
**** define source
#+begin_src emacs-lisp

(consult-omni-define-source "DuckDuckGo API"
                           :narrow-char ?d
                           :type 'dynamic
                           :require-match t
                           :face 'consult-omni-engine-title-face
                           :request #'consult-omni--duckduckgoapi-fetch-results
                           :preview-key consult-omni-preview-key
                           :search-hist 'consult-omni--search-history
                           :select-hist 'consult-omni--selection-history
                           :enabled (lambda () (bound-and-true-p consult-omni-duckduckgo-search-url))
                           :group #'consult-omni--group-function
                           :sort t
                           :static 'both
                           :annotate nil
                           )
#+end_src
**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-duckduckgo' module

(provide 'consult-omni-duckduckgo)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-duckduckgo)
;;; consult-omni-duckduckgo.el ends here
#+end_src


*** elfeed
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-elfeed.el
:END:
**** header

#+begin_src emacs-lisp
;;; consult-omni-elfeed.el --- Consulting Elfeed -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: ((emacs "28.1") (consult "1.4") (consult-omni "0.1") (elfeed "3.4.1"))
;; Homepage: https://github.com/armindarvish/consult-omni/blob/main/consult-omni-sources
;; Keywords: convenience

;;; Commentary:

;;; Code:

(require 'elfeed)
(require 'consult-omni)
#+end_src

**** variables
***** custom
#+begin_src emacs-lisp
;;; Customization Variables
(defcustom consult-omni-elfeed-search-buffer-name "*consult-omni-elfeed-search*"
  "Name for consult-omni-elfeed-search buffer."
  :type 'string)

(defcustom consult-omni-elfeed-default-filter nil
  "Default Filter for consult-omni-elfeed-search."
  :type 'string)
#+end_src
**** helper functions
***** format
#+begin_src emacs-lisp
(defun consult-omni--elfeed-format-candidate (entries query)
"Formats the cnaiddates of `consult-omni-elfeed'.

ENTRIES are entries from `consult-omni--elfeed-fetch-result'.
QUERY is the query input from the user"
  (let ((annotated-entries))
    (dolist (entry entries annotated-entries)
      (let* ((url (elfeed-entry-link entry))
             (urlobj (if url (url-generic-parse-url url)))
             (domain (if (url-p urlobj) (url-domain urlobj)))
             (domain (if (stringp domain) (propertize domain 'face 'consult-omni-domain-face)))
             (path (if (url-p urlobj) (url-filename urlobj)))
             (path (if (stringp path) (propertize path 'face 'consult-omni-path-face)))
             (title (or (elfeed-entry-title entry) ""))
             (title-faces (elfeed-search--faces (elfeed-entry-tags entry)))
             (feed (elfeed-entry-feed entry))
             (feed-title (when feed (elfeed-feed-title feed)))
             (date (format-time-string "%Y-%m-%d %H:%M" (elfeed-entry-date entry)))
             (id (elfeed-entry-id entry))
             (tags (mapcar #'symbol-name (elfeed-entry-tags entry)))
             (tags-str (mapconcat
                        (lambda (s) (propertize s 'face 'elfeed-search-tag-face))
                        tags ","))
             (title-width (- (floor (* (frame-width) 0.7)) elfeed-search-trailing-width))
             (title-column (elfeed-format-column
                            title (elfeed-clamp
                                   elfeed-search-title-min-width
                                   title-width
                                   elfeed-search-title-max-width)
                            :left))
             (match-str (if (stringp query) (consult--split-escaped (car (consult--command-split query))) nil))
             (str (concat (propertize title-column 'face title-faces 'kbd-help title) " "
                          (propertize date 'face 'elfeed-search-date-face)
                          (when feed-title
                            (concat " " (propertize feed-title 'face 'elfeed-search-feed-face)))
                          (when tags (concat " " "(" tags-str ")"))
                          (when domain (concat "\t" domain (when path path)))
                          (concat "\t" (propertize "elfeed" 'face 'consult-omni-source-type-face))
                          )))
        (if consult-omni-highlight-matches
            (cond
             ((listp match-str)
              (mapcar (lambda (match) (setq str (consult-omni--highlight-match match str t))) match-str))
             ((stringp match-str)
              (setq str (consult-omni--highlight-match match-str str t)))))
        (push (propertize str
                          :source "elfeed"
                          :title title
                          :url url
                          :search-url nil
                          :query query
                          :entry entry
                          :tags tags
                          :date date
                          :id id
                          :feed feed
                          )
              annotated-entries)))))
#+end_src
***** make dedicated search buffer
#+begin_src emacs-lisp
(defun consult-omni--elfeed-search-buffer ()
  "Get or create buffer for `consult-omni-elfeed'"
  (get-buffer-create (or consult-omni-elfeed-search-buffer-name "*consult-omni-elfeed-search*")))

#+end_src
***** preview
#+begin_src emacs-lisp

(defun consult-omni--elfeed-preview (cand)
  "Shows a preview buffer of CAND for `consult-omni-elfeed'.
Uses `elfeed-show-entry'."
  (if (listp cand) (setq cand (or (car-safe cand) cand)))
  (let* ((entry (get-text-property 0 :entry cand))
         (buff (get-buffer-create (elfeed-show--buffer-name entry))))
    (with-current-buffer buff
      (elfeed-show-mode)
      (setq elfeed-show-entry entry)
      (elfeed-show-refresh))
    (funcall (consult--buffer-preview) 'preview
             buff
             )))
#+end_src
**** items

#+begin_src emacs-lisp
(cl-defun consult-omni--elfeed-fetch-results (input &rest args &key callback &allow-other-keys)
  "Return entries matching INPUT in elfeed database.
uses INPUT as filter ro find entries in elfeed databse.
if FILTER is non-nil, it is used as additional filter parameters.
"
(cl-letf* (((symbol-function #'elfeed-search-buffer) #'consult-omni--elfeed-search-buffer))
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (seq-difference args (list :callback callback))))
               (opts (car-safe opts))
               (maxcount (plist-get opts :count))
               (filter (and (plist-member opts :filter) (plist-get opts :filter)))
               (maxcount (or (and (integerp maxcount) maxcount)
                             (and maxcount (string-to-number (format "%s" maxcount)))
                             consult-omni-default-count))
               (elfeed-search-filter (concat (if maxcount (format "#%d " maxcount))
                                             (if filter (format "%s" filter)
                                               consult-omni-elfeed-default-filter)
                                             (if query (format "%s" query))
                                             ))
               (filter (elfeed-search-parse-filter elfeed-search-filter))
               (head (list nil))
               (tail head)
               (count 0)
               (lexical-binding t)
               (search-func (byte-compile (elfeed-search-compile-filter filter))))
    (with-elfeed-db-visit (entry feed)
      (when (funcall search-func entry feed count)
        (setf (cdr tail) (list entry)
              tail (cdr tail)
              count (1+ count))))
    (when-let ((entries (cdr head)))
      (consult-omni--elfeed-format-candidate entries query)))
      ))


#+end_src
**** define source
#+begin_src emacs-lisp

(consult-omni-define-source "elfeed"
                           :narrow-char ?e
                           :type 'sync
                           :require-match t
                           :face 'elfeed-search-unread-title-face
                           :request #'consult-omni--elfeed-fetch-results
                           :on-preview #'consult-omni--elfeed-preview
                           :on-return #'identity
                           :on-callback #'consult-omni--elfeed-preview
                           :preview-key consult-omni-preview-key
                           :search-hist 'consult-omni--search-history
                           :select-hist 'consult-omni--selection-history
                           :enabled (lambda () (boundp 'elfeed-db))
                           :group #'consult-omni--group-function
                           :sort t
                           :static 'both
                           :annotate nil
                           )

#+end_src
**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-elfeed' module

(provide 'consult-omni-elfeed)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-elfeed)
;;; consult-omni-elfeed.el ends here
#+end_src

*** Google
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-google.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-omni-google.el --- Consulting Google -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: ((emacs "28.1") (consult "1.4") (consult-omni "0.1"))
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:

;;; Code:

(require 'consult-omni)
#+end_src
**** variables
***** custom
#+begin_src emacs-lisp
(defcustom consult-omni-google-customsearch-key nil
  "Key for Google custom search API

See URL `https://developers.google.com/custom-search/' and URL `https://developers.google.com/custom-search/v1/introduction' for details"
  :group 'consult-omni
  :type '(choice (const :tag "API Key" string)
                 (function :tag "Custom Function")))

(defcustom consult-omni-google-customsearch-cx nil
  "CX for Google custom search API

See URL `https://developers.google.com/custom-search/' and URL `https://developers.google.com/custom-search/v1/introduction' for details"
  :group 'consult-omni
  :type '(choice (const :tag "CX String" string)
                 (function :tag "Custom Function")))


#+end_src
***** other
#+begin_src emacs-lisp
(defvar consult-omni-google-search-url "https://www.google.com/search")

(defvar consult-omni-google-customsearch-api-url "https://www.googleapis.com/customsearch/v1")

#+end_src
**** items

#+begin_src emacs-lisp

(cl-defun consult-omni--google-fetch-results (input &rest args &key callback &allow-other-keys)
  "Fetches search results for INPUT from “Google custom search” service.

Refer to URL `https://programmablesearchengine.google.com/about/' and `https://developers.google.com/custom-search/' for more info.
"
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (seq-difference args (list :callback callback))))
               (opts (car-safe opts))
               (count (plist-get opts :count))
               (page (plist-get opts :page))
               (filter (plist-get opts :filter))
               (count (or (and count (integerp (read count)) (string-to-number count))
                          consult-omni-default-count))
               (page (or (and page (integerp (read page)) (string-to-number page))
                         consult-omni-default-page))
               (filter (or (and (integerp filter) filter)
                           (and filter (string-to-number (format "%s" filter)))
                           1))
               (filter (if (member filter '(0 1)) filter 1))
               (count (min count 10))
               (page (+ (* page count) 1))
               (page (min page (- 100 count)))
               (params `(("q" . ,(replace-regexp-in-string " " "+" query))
                         ("key" . ,(consult-omni-expand-variable-function consult-omni-google-customsearch-key))
                         ("cx" . ,(consult-omni-expand-variable-function consult-omni-google-customsearch-cx))
                         ("gl" . "en")
                         ("filter" . ,(format "%s" filter))
                         ("num" . ,(format "%s" count))
                         ("start" . ,(format "%s" page))))
               (headers '(("Accept" . "application/json")
                          ("Accept-Encoding" . "gzip")
                          ("User-Agent" . "consult-omni (gzip)"))))
    (consult-omni--fetch-url consult-omni-google-customsearch-api-url consult-omni-http-retrieve-backend
                            :encoding 'utf-8
                            :params params
                            :headers headers
                            :parser #'consult-omni--json-parse-buffer
                            :callback
                            (lambda (attrs)
                              (let* ((raw-results (gethash "items" attrs))
                                     (annotated-results
                                           (mapcar (lambda (item)
                                                     (let*
                                                         ((source "Google")
                                                          (url (format "%s" (gethash "link" item)))
                                                          (title (format "%s" (gethash "title" item)))
                                                          (snippet (string-trim (format "%s" (gethash "snippet" item))))
                                                          (search-url (consult-omni--make-url-string consult-omni-google-search-url params '("key" "cx" "gl")))

                                                          (decorated (funcall consult-omni-default-format-candidate :source source :query query :url url :search-url search-url :title title :snippet snippet)))
                                                       (propertize decorated
                                                                   :source source
                                                                   :title title
                                                                   :url url
                                                                   :search-url search-url
                                                                   :query query
                                                                   :snippet snippet)))

                                                   raw-results)))
                                (when (and annotated-results (functionp callback))
                                  (funcall callback annotated-results))
                                annotated-results)))))

#+end_src
**** define source
#+begin_src emacs-lisp
(consult-omni-define-source "Google"
                           :narrow-char ?g
                           :type 'dynamic
                           :require-match t
                           :face 'consult-omni-engine-title-face
                           :request #'consult-omni--google-fetch-results
                           :preview-key consult-omni-preview-key
                           :search-hist 'consult-omni--search-history
                           :select-hist 'consult-omni--selection-history
                           :enabled (lambda () (bound-and-true-p consult-omni-google-customsearch-key))
                           :group #'consult-omni--group-function
                           :sort t
                           :static 'both
                           :annotate nil
                           )
#+end_src
**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-google' module

(provide 'consult-omni-google)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-google)
;;; consult-omni-google.el ends here
#+end_src


*** Google Autosuggest
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-google-autosuggest.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-omni-google-autosuggest.el --- Consulting Google Autosuggest -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: ((emacs "28.1") (consult "1.4") (consult-omni "0.1"))
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:

;;; Code:

(require 'consult-omni)
#+end_src
**** variables
#+begin_src emacs-lisp
(defvar consult-omni-google-autosuggest-api-url "http://suggestqueries.google.com/complete/search")
#+end_src
**** items
#+begin_src emacs-lisp

(cl-defun consult-omni--google-autosuggest-fetch-results (input &rest args &key callback &allow-other-keys)
  "Fetch search results for INPUT from Google Autosuggest.

Uses `consult-omni-google-autosuggest-api-url' as autosuggest api url."
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (seq-difference args (list :callback callback))))
               (opts (car-safe opts))
               (count (plist-get opts :count))
               (page (plist-get opts :page))
               (count (or (and count (integerp (read count)) (string-to-number count))
                          consult-omni-default-count))
               (page (or (and (integerp page) page)
                         (and page (string-to-number (format "%s" page)))
                         consult-omni-default-count))
               (params `(("q" . ,query)
                         ("client" . "chrome")))
               (headers '(("Accept" . "application/json"))))
    (consult-omni--fetch-url consult-omni-google-autosuggest-api-url consult-omni-http-retrieve-backend
                            :encoding 'utf-8
                            :params params
                            :headers headers
                            :parser #'consult-omni--json-parse-buffer
                            :callback
                            (lambda (attrs)
                              (when-let* ((raw-results (append (list (car-safe attrs)) (car-safe (cdr-safe attrs))))
                                          (annotated-results
                                           (mapcar (lambda (item)
                                                     (let* ((source "Google AutoSuggest")
                                                            (word item)
                                                            (url                                  (concat "https://www.google.com/search?q="  (replace-regexp-in-string " " "+" word)))
                                                            (urlobj (and url (url-generic-parse-url url)))
                                                            (domain (and (url-p urlobj) (url-domain urlobj)))
                                                            (domain (and (stringp domain)
                                                                         (propertize domain 'face 'font-lock-variable-name-face)))
                                                            (path (and (url-p urlobj) (url-filename urlobj)))
                                                            (path (and (stringp path)
                                                                       (propertize path 'face 'font-lock-warning-face)))
                                                            (search-url nil)
                                                            (decorated (propertize word 'face 'consult-omni-default-face)))
                                                       (propertize decorated
                                                                   :source source
                                                                   :title word
                                                                   :url url
                                                                   :search-url search-url
                                                                   :query query)))

                                                   raw-results)))
                                (funcall callback annotated-results)
                                annotated-results)))))

#+end_src

**** define source
#+begin_src emacs-lisp
(consult-omni-define-source "Google AutoSuggest"
                           :narrow-char ?G
                           :type 'dynamic
                           :require-match nil
                           :face 'consult-omni-engine-title-face
                           :request #'consult-omni--google-autosuggest-fetch-results
                           :on-preview #'ignore
                           :on-return #'identity
                           :on-callback #'string-trim
                           :search-hist 'consult-omni--search-history
                           :select-hist t
                           :group #'consult-omni--group-function
                           :enabled (lambda () (bound-and-true-p consult-omni-google-autosuggest-api-url))
                           :sort t
                           :static nil
                           )
#+end_src
**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-google-autosuggest' module

(provide 'consult-omni-google-autosuggest)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-google-autosuggest)
;;; consult-omni-google-autosuggest.el ends here
#+end_src


*** gptel
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-gptel.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-omni-gptel.el --- Consulting gptel -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: ((emacs "28.1") (consult "1.4") (consult-omni "0.1") (gptel "0.7.0"))
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:

;;; Code:

(require 'gptel)
(require 'consult-omni)
#+end_src
**** variables
***** custom
#+begin_src emacs-lisp
;;; Customization Variables

(defcustom consult-omni-gptel-backend (or gptel-backend gptel--openai)
  "LLM backend to use in consult-omni-gptel.

By default inherits from `gptel-backend'.
See `gptel-backend' for more info."
  :type `(choice
          (const :tag "ChatGPT" ,gptel--openai)
          (restricted-sexp :match-alternatives (gptel-backend-p 'nil)
           :tag "Other backend")))

(defcustom consult-omni-gptel-model (or gptel-model "gpt-3.5-turbo")
  "GPT Model for use in consult-omni-gptel.

By default inherits from `gptel-model'.
See `gptel-model' for more info."
  :type '(choice
          (string :tag "Specify model name")
          (const :tag "GPT 3.5 turbo" "gpt-3.5-turbo")
          (const :tag "GPT 3.5 turbo 16k" "gpt-3.5-turbo-16k")
          (const :tag "GPT 4" "gpt-4")
          (const :tag "GPT 4 turbo (preview)" "gpt-4-turbo-preview")
          (const :tag "GPT 4 32k" "gpt-4-32k")
          (const :tag "GPT 4 1106 (preview)" "gpt-4-1106-preview")))


(defcustom consult-omni-gptel-buffer-name  "*consult-omni-gptel*"
  "Name for consult-omni-gptel buffer."
  :type '(choice (:tag "A string for buffer name" string)
                 (:tag "A custom function taking prompt (and other args) as input and returning buffer name string" function)))

(defcustom consult-omni-gptel-cand-title #'consult-omni--gptel-make-title-short-answer
  "Name for consult-omni-gptel buffer."
  :type '(choice (:tag "(Default) Get a quickshort answer" #'consult-omni--gptel-make-title-short-answer)
                 (:tag "placeholder string with prompt" #'consult-omni--gptel-make-title-placeholder)
                 (:tag "A custom function taking input (and other args) as input and returning a string" function)
                 (:tag "A custom fixed string" string)))

(defcustom consult-omni-gptel-short-answer-wordcount 10
  "Number of words to use in a short answer"
:type 'integer)

#+end_src

**** helper function
***** format
#+begin_src emacs-lisp
(cl-defun consult-omni--gptel-format-candidate (title &rest args &key source query model backend stream face &allow-other-keys)
  "Returns a formatted string for gptel's candidates

SOURCE is the name string of the source for candidate

QUERY is the query string used for searching

URL is a string pointing to url of the candidate

SEARCH-URL is a string pointing to the url for
the search results of QUERY on the SOURCE website

TITLE is the title of the candidate

SNIPPET is a string containing a snippet/description of candidate
"
  (let* ((frame-width-percent (floor (* (frame-width) 0.1)))
         (source (and (stringp source) (propertize source 'face 'consult-omni-source-type-face)))
         (match-str (and (stringp query) (consult--split-escaped query) nil))
         (backend (and (stringp backend) (propertize backend 'face 'consult-omni-domain-face)))
         (model (and (stringp model) (propertize model 'face 'consult-omni-path-face)))
         (stream (and stream (propertize "~stream~" 'face 'consult-omni-snippet-face)))
         (face (or (consult-omni--get-source-prop source :face) face 'consult-omni-default-face))
         (title-str (and title (stringp title) (propertize title 'face face)))
         (title-str (consult-omni--set-string-width title-str (* 5 frame-width-percent)))
         (str (concat title-str
                      (when backend (concat "\t" backend))
                      (when model (concat ":" model))
                      (when stream (concat "\s" stream "\s"))
                      )))
    (if consult-omni-highlight-matches
        (cond
         ((listp match-str)
          (mapcar (lambda (match) (setq str (consult-omni--highlight-match match str t))) match-str))
         ((stringp match-str)
          (setq str (consult-omni--highlight-match match-str str t)))))
    str))
#+end_src

***** gptel buffer name
#+begin_src emacs-lisp
(defun consult-omni--gptel-buffer-name (&optional query &rest args)
  "Returns a string for `consult-omni-gptel' buffer name"
  (cond
   ((functionp consult-omni-gptel-buffer-name)
    (funcall consult-omni-gptel-buffer-name query args))
   ((stringp consult-omni-gptel-buffer-name)
    consult-omni-gptel-buffer-name)
   (t
    "*consult-omni-gptel*")))
#+end_src
***** preview
#+begin_src emacs-lisp

(cl-defun consult-omni--gptel-response-preview (query &rest args &key backend model stream &allow-other-keys)
  "Returns a `gptel' buffer.

QUERY is sent to BACKEND using MODEL.
If STREAM is non-nil, the response is streamed."
  (save-excursion
    (with-current-buffer (gptel (consult-omni--gptel-buffer-name query args) nil nil nil)
      (let* ((query-sent)
             (backend (and backend (car (seq-filter (lambda (item) (when (string-match (format "%s" backend) item) item)) (mapcar #'car gptel--known-backends)))))
             (backend (or backend (gptel-backend-name consult-omni-gptel-backend)))
             (backend (cdr (assoc (format "%s" backend) gptel--known-backends)))
             (model (or (and model (format "%s" model))
                        (and backend (car (cl-struct-slot-value (type-of backend) 'models backend)))
                        consult-omni-gptel-model))
             (stream (if stream t nil))
             )
        (setq-local gptel-backend backend)
        (setq-local gptel-model model)
        (setq-local gptel-stream stream)
        (erase-buffer)
        (insert (gptel-prompt-prefix-string))
        (insert (format "%s" query))
        (unless query-sent
          (erase-buffer)
          (insert (gptel-prompt-prefix-string) query)
          (setq query-sent t)
          (gptel-send)))
      (current-buffer))))



(defun consult-omni--gptelbuffer-preview (cand)
  "Shows a preview buffer of CAND for `consult-omni-gptel'.

The preview buffer is from `consult-omni--gptel-response-preview'."
  (if (listp cand) (setq cand (or (car-safe cand) cand)))
  (let*  ((query (get-text-property 0 :query cand))
          (backend (get-text-property 0 :backend cand))
          (model (get-text-property 0 :model cand))
          (stream (get-text-property 0 :stream cand))
          (buff (consult-omni--gptel-response-preview query :model model :backend backend :stream stream)))
    (if buff
        (funcall (consult--buffer-preview) 'preview
                 buff
                 ))))
#+end_src
***** title with placeholder
#+begin_src emacs-lisp
(cl-defun consult-omni--gptel-make-title-placeholder (input &rest args &key callback &allow-other-keys)
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (if callback (seq-difference args (list :callback callback)) args)))
               (opts (car-safe opts))
               (source "gptel")
               (backend (and (plist-member opts :backend) (format "%s" (plist-get opts :backend))))
               (backend (and backend (car (seq-filter (lambda (item) (when (string-match (format "%s" backend) item) item)) (mapcar #'car gptel--known-backends)))))
               (backend (or backend (gptel-backend-name consult-omni-gptel-backend)))
               (backend-struct  (cdr (assoc (format "%s" backend) gptel--known-backends)))
               (model (and (plist-member opts :model) (format "%s" (plist-get opts :model))))
               (model (or (and model backend-struct (member model (cl-struct-slot-value (type-of backend-struct) 'models backend-struct)) model)
                          (and backend-struct (car (cl-struct-slot-value (type-of backend-struct) 'models backend-struct)))))
               (stream (or (and (plist-member opts :stream) (plist-get opts :stream)) gptel-stream))
               (placeholder (format "ask gptel: %s" (if query (string-trim-right query) "")))
               (decorated (consult-omni--gptel-format-candidate placeholder :source source :query query :model model :backend backend :stream stream))
               (annotated-results
                (propertize decorated
                            :source source
                            :title query
                            :url nil
                            :query query
                            :model model
                            :stream stream
                            :backend backend)))
    (when (and annotated-results (functionp callback))
        (funcall callback (list annotated-results)))
      (list annotated-results)))
#+end_src
***** title with  short answer
#+begin_src emacs-lisp
(cl-defun consult-omni--gptel-make-title-short-answer (input &rest args &key callback &allow-other-keys)
"Get a short answer preview from gptel."
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (if callback (seq-difference args (list :callback callback)) args)))
               (opts (car-safe opts))
               (source "gptel")
               (backend (and (plist-member opts :backend) (format "%s" (plist-get opts :backend))))
               (backend (and backend (car (seq-filter (lambda (item) (when (string-match (format "%s" backend) item) item)) (mapcar #'car gptel--known-backends)))))
               (backend (or backend (gptel-backend-name consult-omni-gptel-backend)))
               (backend-struct (cdr (assoc (format "%s" backend) gptel--known-backends)))
               (model (and (plist-member opts :model) (format "%s" (plist-get opts :model))))
               (model (or (and model backend-struct (member model (cl-struct-slot-value (type-of backend-struct) 'models backend-struct)) model)
                          (and backend-struct (car (cl-struct-slot-value (type-of backend-struct) 'models backend-struct)))
                          consult-omni-gptel-model))
               (stream (or (and (plist-member opts :stream) (plist-get opts :stream)) gptel-stream))
               (gptel-backend backend-struct)
               (gptel-model model)
               (gptel-stream (if stream t nil))
               (output))
    (gptel-request query
      :system (format "Respond in %s words or less." consult-omni-gptel-short-answer-wordcount)
      :callback
      (lambda (response _)
        (when response
          (let* ((decorated
                (consult-omni--gptel-format-candidate (string-trim-right response) :source source :query query :model model :backend backend :stream stream))
                 (annotated-result (propertize decorated
                        :title response
                        :source "gptel"
                        :url nil
                        :query query
                        :model model
                        :stream stream
                        :backend backend)))
        (when annotated-result
          (when callback
            (funcall callback (list annotated-result)))
          (setq output (list annotated-result)))))))
    output))
#+end_src
**** items
#+begin_src emacs-lisp
(cl-defun consult-omni--gptel-fetch-results (input &rest args &key callback &allow-other-keys)
  "Makes cnaidate with INPUT as placeholder for `consult-omni-gptel'.

This makes a placeholder string “ask gptel: %s” %s=INPUT with
metadata so it can be send to `gptel'."
  (unless (featurep 'gptel)
    (error "consult-omni: gptel is not available. Make sure to install and load `gptel'."))
  (let ((results))
    (cond
     ((stringp consult-omni-gptel-cand-title) (setq results (list consult-omni-gptel-cand-title)))
     ((functionp consult-omni-gptel-cand-title)
           (setq results (apply consult-omni-gptel-cand-title input :callback callback args))))
    results
    ))
#+end_src
**** define source
#+begin_src emacs-lisp

(consult-omni-define-source "gptel"
                           :narrow-char ?a
                           :type 'dynamic
                           :require-match t
                           :face 'consult-omni-ai-title-face
                           :request #'consult-omni--gptel-fetch-results
                           :on-preview #'consult-omni--gptelbuffer-preview
                           :on-return #'identity
                           :on-callback #'consult-omni--gptelbuffer-preview
                           :preview-key consult-omni-preview-key
                           :search-hist 'consult-omni--search-history
                           :select-hist 'consult-omni--selection-history
                           :enabled (lambda () (fboundp 'gptel))
                           :group #'consult-omni--group-function
                           :sort t
                           :static 'both
                           :annotate nil
                           )

#+end_src

**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-gptel' module

(provide 'consult-omni-gptel)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-gptel)
;;; consult-omni-gptel.el ends here
#+end_src


*** Invidious
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-invidious.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-omni-invidious.el --- Consulting Invidious -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: ((emacs "28.1") (consult "1.4") (consult-omni "0.1"))
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:

;;; Code:

(require 'consult-omni)
#+end_src
**** variabels
***** other
#+begin_src emacs-lisp
(defvar consult-omni-invidious-servers nil)
(defvar consult-omni-invidious-server-url "https://api.invidious.io/instances.json")
#+end_src
**** helper functions
***** get servers
#+begin_src emacs-lisp
(defun consult-omni--invidious-get-servers (&optional rotate)
  "Get list of Invidious API servers.
"
  (when (and consult-omni-invidious-servers rotate)
    (setq consult-omni-invidious-servers
          (nconc (cdr consult-omni-invidious-servers)
                 (list (car consult-omni-invidious-servers)))))
  (or consult-omni-invidious-servers
      (setq consult-omni-invidious-servers
            (let ((params `(("pretty" . "1")
                                  ("sort_by" . "type"))))
       (consult-omni--fetch-url
        consult-omni-invidious-server-url
        consult-omni-http-retrieve-backend
        :params params
        :sync t
        :parser #'consult-omni--json-parse-buffer
        :callback (lambda (attrs)
  (delq nil (mapcar (lambda (item)
                      (when (equal (gethash "api" (cadr item)) t)
                                  (gethash "uri" (cadr item))
                      )

                      ) attrs))
))))))
#+end_src

***** format
#+begin_src emacs-lisp
(cl-defun consult-omni--invidious-format-candidate (&rest args &key source type query title snippet channeltitle date subcount videocount viewcount length face &allow-other-keys)
"Formats a candidate for `consult-omni-invidious' commands.

SOURCE is the name to use (e.g. “Invidious”)

TYPE is the type of candidate (e.g. video, channel, playlist)

QUERY is the query input from the user

TITLE is the title of the video

SNIPPET is a string containing a snippet/description of the video

CHANNELTITLE is the name of the channel for the video

DATE is the publish date of the video

SUBCOUNT is the subscriber count fpr a channel

VIDEOCOUNT is the number of videos in a playlist

VIEWCOUNT is the number of times a video is viewed

LENGTH is the duration of a  video in seconds

FACE is the face to apply to TITLE
"
  (let* ((frame-width-percent (floor (* (frame-width) 0.1)))
         (source (propertize source 'face 'consult-omni-source-type-face))
         (match-str (if (stringp query) (consult--split-escaped query) nil))
         (videocount-str (and videocount (consult-omni--numbers-human-readable (or videocount 0) "videos")))
         (viewcount-str (and viewcount (consult-omni--numbers-human-readable (or viewcount 0) "views")))
         (subcount-str (and subcount (consult-omni--numbers-human-readable (or subcount 0) "subs")))
         (stats (and type
                    (stringp type)
                    (propertize
                     (consult-omni--set-string-width (pcase type
                      ("video" (format "%s" (or viewcount-str "0 views")))
                      ("playlist" (format "%s" (or videocount-str "0 videos")))
                      ("channel" (format "%s" (or subcount-str "0 subscriptions")))
                      (_ "")) 10)
                     'face 'consult-omni-domain-face)))
         (length (or
                  (and (numberp length) (seconds-to-string length))
                  (and (equal type "playlist") "[PLAYLIST]")
                  (and (equal type "channel") "(CHANNEL)")))
         (length (and (stringp length) (consult-omni--set-string-width (propertize length 'face 'consult-omni-comment-face) 10)))
         (date (propertize (or (and (stringp date) date) (make-string 10 ?\s)) 'face 'consult-omni-date-face))
         (channeltitle (and channeltitle (stringp channeltitle) (propertize channeltitle 'face 'consult-omni-path-face)))
         (channeltitle (consult-omni--set-string-width channeltitle (* 2 frame-width-percent)))
         (snippet (if (stringp snippet) (consult-omni--set-string-width (replace-regexp-in-string "\n" "  " snippet) (* 2 frame-width-percent))))
         (snippet (and snippet (stringp snippet) (propertize snippet 'face 'consult-omni-snippet-face)))
         (face (or (consult-omni--get-source-prop source :face) face 'consult-omni-default-face))
         (title-str (and title (propertize title 'face face)))
         (title-str (consult-omni--set-string-width title-str (* 5 frame-width-percent)))
         (str (concat title-str
                      (when date (concat "\s" date))
                      (when channeltitle (concat " " channeltitle))
                      (propertize " " 'display `(space :align-to ,(+ (* 5 frame-width-percent)                                                                      11)))
                      (when length (concat "\s" length))
                      (unless (string-empty-p stats) (concat "\s" stats))
                      (when snippet (concat "\s\s" snippet))
                      (concat "\t" source)))
         )
    (if consult-omni-highlight-matches
        (cond
         ((listp match-str)
          (mapcar (lambda (match) (setq str (consult-omni--highlight-match match str t))) match-str))
         ((stringp match-str)
          (setq str (consult-omni--highlight-match match-str str t)))))
    str))
#+end_src

**** items
#+begin_src emacs-lisp
(cl-defun consult-omni--invidious-fetch-results (input &rest args &key callback &allow-other-keys)
  "Fetches search results for INPUT from “Invidious” service."
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (seq-difference args (list :callback callback))))
               (opts (car-safe opts))
               (count (plist-get opts :count))
               (page (plist-get opts :page))
               (type (plist-get opts :type))
               (order (or (plist-get opts :order) (plist-get opts :sort)))
               (channel (or (plist-get opts :channel) (plist-get opts :user)))
               (subs (or (plist-get opts :subs) (plist-get opts :subscriptions)))
               (searchdate (plist-get opts :date))
               (searchdate (if searchdate (format "%s" searchdate)))
               (features (plist-get opts :features))
               (features (if features (format "%s" features)))
               (duration (plist-get opts :dur))
               (duration (if duration (format "%s" duration)))
               (count (or (and count (integerp (read count)) (string-to-number count))
                          consult-omni-default-count))
               (page (or (and (integerp page) page)
                         (and page (string-to-number (format "%s" page)))
                         consult-omni-default-count))
               (count (min count 10))
               (page (+ (* page count) 1))
               (order  (if (and order (member (format "%s" order) '("date" "rating" "relevance" "upload_date" "views" "view_count"))) (format "%s" order) "relevance"))
               (type (if (and type (member (format "%s" type) '("channel" "playlist" "video" "movie" "show" "all"))) (format "%s" type) "video"))
               (params (delq nil `(("q" . ,(replace-regexp-in-string " " "+" query))
                         ("sort_by" . ,order)
                         ("type" . ,type)
                         ,(when searchdate `("date" . ,searchdate))
                         ,(when features `("features" . ,features))
                         ,(when duration `("duration" . ,duration))
                         ,(when subs `("subscriptions" . ,(if subs "true" "false"))))))
               (server-url (car (consult-omni--invidious-get-servers)))
               (api-url (concat server-url "/api/v1/search?")))
    (consult-omni--fetch-url api-url consult-omni-http-retrieve-backend
                            :encoding 'utf-8
                            :params params
                            :parser #'consult-omni--json-parse-buffer
                            :callback
                            (lambda (attrs)
                              (let* ((raw-results attrs)
                                     (annotated-results
                                      (mapcar (lambda (item)
                                                (let*
                                                    ((source "Invidious")
                                                     (item-type (gethash "type" item))
                                                     (channelhandle (gethash "channelHandle" item))
                                                     (title (or (gethash "title" item)
                                                                (unless (eq channelhandle :null) channelhandle)
                                                                (gethash "author" item)
                                                                ))
                                                     (videos  (gethash "videos" item))
                                                     (videoid (or (gethash "videoId" item)
                                                                  (and videos (gethash "videoId" (car videos)))))
                                                     (channeltitle (gethash "author" item))
                                                     (channelid (gethash "authorId" item))
                                                     (playlistid (gethash "playlistId" item))
                                                     (videocount (gethash "videoCount" item))
                                                     (subcount (gethash "subCount" item))
                                                     (viewcount (gethash "viewCount" item))
                                                     (videolength (gethash "lengthSeconds" item))
                                                     (date (gethash "published" item))
                                                     (date (when date (format-time-string "%Y-%m-%d" (seconds-to-time date))))
                                                     (url (cond
                                                           ((and playlistid videoid) (consult-omni--make-url-string consult-omni-youtube-watch-url `(("v" . ,videoid)
                               ("list" . ,playlistid))))
                                                           (playlistid (consult-omni--make-url-string consult-omni-youtube-watch-url `(("list" . ,playlistid))))
                                                           (videoid (consult-omni--make-url-string consult-omni-youtube-watch-url `(("v" . ,videoid))))

                                                           (channelid (concat consult-omni-youtube-channel-url channelid))))
                                                     (search-url (consult-omni--make-url-string server-url params))
                                                     (description (gethash "description" item))

                                                     (decorated (consult-omni--invidious-format-candidate :source source :type item-type :query query :title title :snippet description :channeltitle channeltitle :date date :subcount subcount :videocount videocount :viewcount viewcount :length videolength)))
                                                (propertize decorated
                                                            :source source
                                                            :title title
                                                            :url url
                                                            :search-url search-url
                                                            :query query
                                                            :snippet description
                                                            :videoid videoid
                                                            :channeltitle channeltitle
                                                            :channelid channelid
                                                            :duration duration
:views viewcount
:videocount videocount
:subscriptions subcount)))

                                      raw-results)))
                              (when (and annotated-results (functionp callback))
                                (funcall callback annotated-results))
                              annotated-results)
                              ))))

#+end_src
**** define source
#+begin_src emacs-lisp
(consult-omni-define-source "Invidious"
                           :narrow-char ?y
                           :type 'dynamic
                           :require-match t
                           :category 'consult-omni-video
                           :face 'consult-omni-engine-title-face
                           :request #'consult-omni--invidious-fetch-results
                           :preview-key consult-omni-preview-key
                           :search-hist 'consult-omni--search-history
                           :select-hist 'consult-omni--selection-history
                           :enabled (lambda () (bound-and-true-p consult-omni-invidious-server-url))
                           :group #'consult-omni--group-function
                           :sort t
                           :static 'both
                           :annotate nil
                           )
#+end_src

**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-invidious' module

(provide 'consult-omni-invidious)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-invidious)
;;; consult-omni-invidious.el ends here
#+end_src


*** notmuch
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-notmuch.el
:END:
**** header

#+begin_src emacs-lisp
;;; consult-omni-notmuch.el --- Consulting Notmuch Command -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: ((emacs "28.1") (consult "1.4") (consult-omni "0.1") (consult-notmuch "0.8.1"))
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:

;;; Code:

(require 'consult-omni)
(require 'notmuch)
#+end_src
**** variables
***** custom
#+begin_src emacs-lisp
(defcustom consult-omni-notmuch-message-buffer-name "*consult-omni-notmuch-message*"
  "Name of notmuch preview and result buffers."
  :type 'string)

(defcustom consult-omni-notmuch-tree-buffer-name "*consult-omni-notmuch-tree*"
  "Name of notmuch preview and result buffers."
  :type 'string)

(defcustom consult-omni-notmuch-command (or notmuch-command "notmuch")
  "Name of the notmuch binary.

By default inherits from `notmuch-command'."
  :type 'string)

(defcustom consult-omni-notmuch-default-command-arg "search"
  "Default notmuch commandline arg for finding messages.
Can be either “search” or “show”"
  :type  '(choice (const :tag "(Default) search" "search")
                  (const :tag "show" "show"))
  )

(defcustom consult-omni-notmuch-extra-command-args (list)
"extra notmuch commandline arguments."

 :type '(repeat (choice string)))

(defcustom consult-omni-notmuch-default-count consult-omni-default-count
   "Number of notmuch search results to retrieve."
 :type 'integer)

#+end_src
***** other
#+begin_src emacs-lisp
(setq consult-omni--notmuch-format-func-alist '(("show" . consult-omni--notmuch-show-transform)
                                                  ("search" . consult-omni--notmuch-search-transform)))
#+end_src
**** helper functions
***** transform/format
****** format cnadidates
#+begin_src emacs-lisp
(cl-defun consult-omni--notmuch-format-candidate (&rest args &key source query title from date tags face &allow-other-keys)
  "Transform STR from notmuch search to consult-omni-notmuch style."
  (let* ((frame-width-percent (floor (* (frame-width) 0.1)))
         (source (if (stringp source) (propertize source 'face 'consult-omni-source-type-face) nil))
         (match-str (if (stringp query) (consult--split-escaped query) nil))
         (date (if (stringp date) (propertize date 'face 'consult-omni-date-face) "            "))
         (from (if (stringp from) (propertize from 'face 'consult-omni-path-face) ""))
         (from-str (and (stringp from) (consult-omni--set-string-width from (* 2 frame-width-percent))))
         (tags (cond ((and tags (listp tags)) (format "(%s)" (mapconcat #'identity tags ", ")))
                     ((and tags (stringp tags)) tags)
                     (t nil)))
         (tags (and tags (stringp tags) (propertize tags 'face 'consult-omni-keyword-face)))
         (face (or (consult-omni--get-source-prop source :face) face 'consult-omni-default-face))
         (title-str (if (stringp title) (propertize title 'face face)))
         (title-str (if (stringp title-str) (consult-omni--set-string-width title-str (* 5 frame-width-percent))))
         (str (if (string-empty-p from) ""
                (concat (if date (format "%s" date))
                      (if from-str (format "\s%s" from-str))
                      "\t"
                      (if title-str title-str)
                      (if tags (format "\s\s%s" tags))
                      (if source (concat "\t" source))))))
    (if consult-omni-highlight-matches
        (cond
         ((and (listp match-str) (stringp str))
          (mapcar (lambda (match) (setq str (consult-omni--highlight-match match str t))) match-str))
         ((and (stringp match-str) (stringp str))
          (setq str (consult-omni--highlight-match match-str str t)))))
     str))
#+end_src
****** transform show
#+begin_src emacs-lisp

(defun consult-omni--notmuch-search-transform (candidates &optional query)

  (remove nil (remove "" (mapcar (lambda (item)
                        (when (and (stringp item) (string-match "thread:" item))
                          (let* ((source "notmuch")
                                 (id (car (split-string item "\\ +")))
                                 (date (substring item 24 37))
                                 (mid (substring item 24))
                                 (c0 (string-match "[[]" mid))
                                 (c1 (string-match "[]]" mid))
                                 (count (substring mid c0 (1+ c1)))
                                 (senders (string-trim (nth 1 (split-string mid "[];]"))))
                                 (subject (string-trim (nth 1 (split-string mid "[;]"))))
                                 (headers (list :Subject subject :From senders))
                                 (t0 (string-match "([^)]*)\\s-*$" mid))
                                 (tags (split-string (substring mid (1+  t0) -1)))
                                 (decorated (consult-omni--notmuch-format-candidate :source source :query query :title subject :from senders :date date :tags tags)))
                            (when (and (stringp decorated) (not (string-empty-p decorated))) (propertize decorated
                                        :source source
                                        :query query
                                        :title subject
                                        :url nil
                                        :search-url nil
                                        :id id
                                        :from senders
                                        :date date
                                        :match t
                                        :headers headers
                                        :count count
                                        :tags tags
                                        )))))
                      candidates)
          )))
#+end_src
****** transform search
#+begin_src emacs-lisp
(defun consult-omni--notmuch-show-transform (candidates &optional query)
  "Parse output STR of notmuch show, extracting its components."

  (let ((source "notmuch") (id) (headers) (subject) (senders) (cc) (to) (count) (date) (tags) (match) (info))
    (remove nil (mapcar (lambda (item)
                          (if (string-prefix-p "message}" item)
                              (prog1
                                  (let* ((subject (or subject (plist-get headers :Subject)))
                                         (date  (or date (plist-get headers :Date)))
                                         (senders (or senders (plist-get headers :From)))
                                         (cc  (or cc (plist-get headers :Cc)))
                                         (to  (or to (plist-get headers :To)))
                                         (decorated (consult-omni--notmuch-format-candidate :source source :query query :title subject :from senders :date date :tags tags)))
                                    (when (and (stringp decorated) (not (string-empty-p decorated)))
                                      (propertize decorated
                                                :source source
                                                :query query
                                                :title subject
                                                :url nil
                                                :search-url nil
                                                :id id
                                                :from senders
                                                :date date
                                                :match t
                                                :headers headers
                                                :count count
                                                :tags tags
                                                )))
                                (setq id nil
                                      headers nil
                                      senders nil
                                      subject nil
                                      count nil
                                      date nil
                                      tags nil
                                      match nil
                                      info nil
                                      ))
                            (cond ((string-match "message{ \\(id:[^ ]+\\) .+" item)
                                   (setq id (match-string 1 item))
                                   (setq match t))
                                  ((string-prefix-p "header{" item)
                                   (setq info t))
                                  ((and item info)
                                   (cond ((string-match "\\(.+\\) (\\([^)]+\\)) (\\([^)]*\\))$" item)
                                          (setq senders (match-string 1 item))
                                          (setq date (match-string 2 item))
                                          (setq tags (split-string (match-string 3 item))))
                                         ((string-match "\\(Subject\\|From\\|To\\|Cc\\|Date\\): \\(.+\\)?" item)
                                          (let ((k (intern (format ":%s" (match-string 1 item))))
                                                (v (or (match-string 2 item) "")))
                                            (setq headers
                                                  (plist-put headers k v))))
                                         )
                                   )
                                  ((string-prefix-p "header}" item)
                                   (setq info nil))
                                  )
                            nil)) candidates))))
#+end_src
****** default transform
#+begin_src emacs-lisp
(defun consult-omni--notmuch-get-transform-func (&rest args)
    (cdr (assoc consult-omni-notmuch-default-command-arg consult-omni--notmuch-format-func-alist)))
#+end_src
***** preview
#+begin_src emacs-lisp
(defun consult-omni--notmuch--preview (cand)
  "Preview function for notmuch candidates."
  (let* ((query (get-text-property 0 :query cand))
         (id (get-text-property 0 :id cand)))
    (when id
      (when (get-buffer consult-notmuch--buffer-name)
        (kill-buffer consult-notmuch--buffer-name))
      (notmuch-show id nil nil query consult-omni-notmuch-message-buffer-name))))
#+end_src
***** return
***** callback
#+begin_src emacs-lisp
(defun consult-omni--notmuch-callback (cand)
  "Callback function for notmuch candidates.
"
  (let* ((query (get-text-property 0 :query cand))
         (id (get-text-property 0 :id cand)))
    (when id
      (when (get-buffer consult-omni-notmuch--buffer-name)
        (kill-buffer consult-omni-notmuch--buffer-name))
      (notmuch-tree query nil id consult-omni-notmuch-tree-buffer-name t nil nil nil)))
)


#+end_src
**** items
#+begin_src emacs-lisp
(cl-defun consult-omni--notmuch-command-builder (input &rest args &key callback &allow-other-keys)
  "makes builder command line args for “notmuch”.
"
  (setq consult-notmuch--partial-parse nil)
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (seq-difference args (list :callback callback))))
               (opts (car-safe opts))
               (count (plist-get opts :count))
               (page (plist-get opts :page))
               (count (or (and count (integerp (read count)) (string-to-number count))
                          consult-omni-notmuch-default-count))
               (page (or (and page (integerp (read page)) (string-to-number page))
                         consult-omni-default-page))
               (page (* count page))
               (consult-omni-notmuch-extra-command-args (unless (listp consult-omni-notmuch-extra-command-args) (list consult-omni-notmuch-extra-command-args)))
               (cmd (append (list notmuch-command) (list consult-omni-notmuch-default-command-arg) (when count (list "--limit" (format "%s" count))) (when (and page (not (equal page 0))) (list "--offset" (format "%s" page)))  consult-omni-notmuch-extra-command-args (list query)))
               )
    cmd
  ))
#+end_src
**** define source
#+begin_src emacs-lisp
(consult-omni-define-source "notmuch"
                           :narrow-char ?m
                           :type 'async
                           :require-match nil
                           :category 'notmuch-result
                           :face 'consult-omni-engine-title-face
                           :request #'consult-omni--notmuch-command-builder
                           :on-preview #'consult-omni--notmuch--preview
                           :on-return #'identity
                           :on-callback #'consult-omni--notmuch-callback
                           :preview-key consult-omni-preview-key
                           :search-hist 'consult-omni--search-history
                           :select-hist 'consult-omni--selection-history
                           :group #'consult-omni--group-function
                           :sort t
                           :static 'both
                           :transform (lambda (candidates &optional query) (funcall (consult-omni--notmuch-get-transform-func) candidates query))
                           :enabled (lambda () (if (and (bound-and-true-p notmuch-command) (executable-find notmuch-command))
                                                   t nil))
                           :annotate nil
                           )
#+end_src

**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-notmuch' module

(provide 'consult-omni-notmuch)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-notmuch)
;;; consult-omni-notmuch.el ends here
#+end_src

*** Numi
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-numi.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-omni-numi.el --- Consulting numi Command -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: ((emacs "28.1") (consult "1.4") (consult-omni "0.1"))
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:

;;; Code:

(require 'consult-omni)
#+end_src

**** custom variables
#+begin_src emacs-lisp
(defcustom consult-omni-numi-args "numi-cli"
"Command line arguments for mdfind.

Similar to other command line args for consult but for mdfind.
See `consult-locate-args' for example."
  :type '(choice string (repeat (choice string sexp))))
#+end_src

**** helper functions
***** preview
#+begin_src emacs-lisp

(defun consult-omni--numi-preview (cand)
  "Mdfind preview function.")
#+end_src

***** callback
#+begin_src emacs-lisp
(defun consult-omni--numi-callback (cand)
  "Muni callback function."
  (let ((result  (get-text-property 0 :title cand)))
  (kill-new result))
  )
#+end_src


***** filter
#+begin_src emacs-lisp
(defun consult-omni--numi-filter (candidates &optional query)
  "Formats `consult-omni-mdfind' candidates.
"
  (cl-loop for candidate in candidates
           when (not (equal candidate "?"))
           collect candidate))

#+end_src
**** items
#+begin_src emacs-lisp
(cl-defun consult-omni--numi-builder (input &rest args &key callback &allow-other-keys)
  "makes builder command line args for “mdfind”.
"
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (seq-difference args (list :callback callback))))
               (opts (car-safe opts)))
    (funcall #'consult-omni--async-builder (shell-quote-argument query) consult-omni-numi-args)
   ;; (funcall #'consult--locate-builder (shell-quote-argument query))
   ;; (list consult-omni-numi-args query)
            ))
#+end_src

**** define source
#+begin_src emacs-lisp
(consult-omni-define-source "Numi"
                           :narrow-char ?N
                           :category 'consult-omni-calc
                           :type 'async
                           :require-match t
                           :face 'consult-omni-engine-title-face
                           :request #'consult-omni--numi-builder
                           :filter #'consult-omni--numi-filter
                           :on-preview #'ignore
                           :on-return #'identity
                           :on-callback #'consult-omni--numi-callback
                           :preview-key consult-omni-preview-key
                           :search-hist 'consult-omni--search-history
                           :select-hist 'consult-omni--selection-history
                           :group #'consult-omni--group-function
                           :enabled (lambda () (if (executable-find "numi-cli") t nil))
                           :sort t
                           :static 'both
                           :annotate nil
                           )
#+end_src

**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-numi module

(provide 'consult-omni-numi)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-numi)
;;; consult-omni-numi.el ends here
#+end_src



*** PubMed
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-pubmed.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-omni-pubmed.el --- Consulting PubMed -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: ((emacs "28.1") (consult "1.4") (consult-omni "0.1"))
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:

;;; Code:

(require 'consult-omni)
#+end_src
**** variables
***** custom
#+begin_src emacs-lisp
(defcustom consult-omni-pubmed-api-key nil
  "Key for Pubmed Entrez API.

See URL `https://www.ncbi.nlm.nih.gov/books/NBK25501/' for more info"
  :group 'consult-omni
  :type '(choice (const :tag "API Key" string)
                 (function :tag "Custom Function")))
#+end_src
***** other
#+begin_src emacs-lisp
(defvar consult-omni-pubmed-search-url "https://pubmed.ncbi.nlm.nih.gov/")

(defvar  consult-omni-pubmed-esearch-api-url "https://eutils.ncbi.nlm.nih.gov/entrez/eutils/esearch.fcgi")

(defvar consult-omni-pubmed-esummary-api-url "https://eutils.ncbi.nlm.nih.gov/entrez/eutils/esummary.fcgi")


#+end_src
**** helper functions
***** format
#+begin_src emacs-lisp
(cl-defun consult-omni-dynamic--pubmed-format-candidate (&rest args &key source query url search-url title authors date journal doi face &allow-other-keys)
  "Returns a formatted string for candidates of `consult-omni-pubmed'.

SOURCE is the name to use (e.g. “PubMed”)

QUERY is the query input from the user

URL is the url of  candidate

SEARCH-URL is the web search url
(e.g. https://pubmed.ncbi.nlm.nih.gov/?term=QUERY)

TITLE is the title of the result/paper (e.g. title of paper)

AUTHORS are authors of the result/paper

DATE is the publish date of the result/paper

JOURNAL is the journal that the result/paper is published in

DOI is doi of the result/paper

FACE is the face to apply to TITLE
"
  (let* ((frame-width-percent (floor (* (frame-width) 0.1)))
         (source (if (stringp source) (propertize source 'face 'consult-omni-source-type-face) nil))
         (date (if (stringp date) (propertize date 'face 'consult-omni-date-face) nil))
         (journal (if (stringp journal) (propertize journal 'face 'consult-omni-domain-face) nil))
         (authors (cond
                   ((and authors (listp authors))
                    (concat (first authors) ",..., " (car (last authors))))
                   ((stringp authors)
                    authors)
                   (t nil)))
         (authors (if (and authors (stringp authors)) (propertize authors 'face 'consult-omni-source-type-face)))
         (doi (if (stringp doi) (propertize doi 'face 'link)))
         (match-str (if (stringp query) (consult--split-escaped query) nil))
         (face (or (consult-omni--get-source-prop source :face) face 'consult-omni-default-face))
         (title-str (propertize title 'face face))
         (title-str (consult-omni--set-string-width title-str (* 5 frame-width-percent)))
         (str (concat title-str
                      (if journal (format "\t%s" journal))
                      (if date (format "\s\s%s" date))
                      (if authors (format "\s\s%s" authors))
                      (if source (concat "\t" source))))
         )
    (if consult-omni-highlight-matches
        (cond
         ((listp match-str)
          (mapcar (lambda (match) (setq str (consult-omni--highlight-match match str t))) match-str))
         ((stringp match-str)
          (setq str (consult-omni--highlight-match match-str str t)))))
    str))
#+end_src
**** items
***** esearch
#+begin_src emacs-lisp

(cl-defun consult-omni--pubmed-esearch-fetch-results (input &rest args &key db &allow-other-keys)
  "Fetches “esearch” results for INPUT from PubMed Entrez Utilities service.

DB is passed as db in query parameters. (This is the database to search.)

Refer to URL `https://www.ncbi.nlm.nih.gov/books/NBK25501/'
for more info."

  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (seq-difference args (list :db db))))
               (opts (car-safe opts))
               (count (plist-get opts :count))
               (page (plist-get opts :page))
               (count (or (and count (integerp (read count)) (string-to-number count))
                          consult-omni-default-count))
               (page (or (and page (integerp (read page)) (string-to-number page))
                         consult-omni-default-page))
               (count (min count 20))
               (page (* page count))
               (db (if db (format "%s" db) "pubmed"))
               (params `(("db" . ,db)
                         ("term" . ,(replace-regexp-in-string " " "+" query))
                         ("usehistory" . "y")
                         ("retmax" . ,(format "%s" count))
                         ("retstart" . ,(format "%s" page))
                         ("retmode" . "json")
                         ))
               (headers `(("tool" . "consult-omni")
                          ("email" . "contact@armindarvish.com")
                          ("api_key" . ,(consult-omni-expand-variable-function consult-omni-pubmed-api-key)))))
    (consult-omni--fetch-url
     consult-omni-pubmed-esearch-api-url consult-omni-http-retrieve-backend
     :sync t
     :params params
     :headers headers
     :parser #'consult-omni--json-parse-buffer
     :callback
     (lambda (attrs)
       (let* ((results (gethash "esearchresult" attrs))
              (webenv (gethash "webenv" results))
              (qk (gethash "querykey" results))
              (idlist (gethash "idlist" results)))
         `(:webenv ,webenv :qk ,qk :idlist ,idlist)
         )))
    ))


#+end_src
***** esummary
#+begin_src emacs-lisp

(cl-defun consult-omni--pubmed-esummary-fetch-results (input &rest args &key callback webenv qk db &allow-other-keys)
  "Fetches “esummary” results for INPUT from PubMed Entrez Utilities service.

WEBENV is passed as webenv in query parameters

qk is passed as qk in query parameters

DB is passed as db in query parameters. (This is the databes to search.)

Refer to URL `https://www.ncbi.nlm.nih.gov/books/NBK25501/'
for more info."

  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (seq-difference args (list :callback callback :webenv webenv :qk qk :db db))))
               (opts (car-safe opts))
               (count (plist-get opts :count))
               (page (plist-get opts :page))
               (count (or (and count (integerp (read count)) (string-to-number count))
                          consult-omni-default-count))
               (page (or (and page (integerp (read page)) (string-to-number page))
                         consult-omni-default-page))
               (page (* page count))
               (webenv (if webenv (format "%s" webenv)))
               (qk (if qk (format "%s" qk)))
               (retmax (min count 500))
               (retstart (max 0 page))
               (db (if db (format "%s" db) "pubmed"))
               (params `(("db" . ,db)
                         ("query_key" . ,qk)
                         ("WebEnv" . ,webenv)
                         ("retmax" . ,(format "%s" retmax))
                         ("retstart" . ,(format "%s" retstart))
                         ("retmode" . "json")
                         ))
               (headers `(("tool" . "consult-omni")
                          ("email" . "contact@armindarvish.com")
                          ("api_key" . ,(consult-omni-expand-variable-function consult-omni-pubmed-api-key)))))
    (consult-omni--fetch-url consult-omni-pubmed-esummary-api-url consult-omni-http-retrieve-backend
                            :encoding 'utf-8
                            :params params
                            :headers headers
                            :parser #'consult-omni--json-parse-buffer
                            :callback
                            (lambda (attrs)
                              (let* ((results (gethash "result" attrs))
                                     (uids (gethash "uids" results))
                                     (annotated-results
                                           (mapcar (lambda (uid)
                                                     (let*
                                                         ((source "PubMed")
                                                          (url (url-unhex-string (concat consult-omni-pubmed-search-url (format "%s" uid))))
                                                          (search-url (consult-omni--make-url-string consult-omni-pubmed-search-url `(("term" . ,(replace-regexp-in-string " " "+" query)))))
                                                          (data (gethash uid results))
                                                          (title (gethash "title" data))
                                                          (pubdate (date-to-time (gethash "pubdate" data)))
                                                          (date (format-time-string "%Y-%m-%d" pubdate))
                                                          (journal (gethash "fulljournalname" data))
                                                          (authors (mapcar (lambda (item) (gethash "name" item)) (gethash "authors" data)))
                                                          (ids (gethash "articleids" data))
                                                          (doi (car (remove nil (mapcar (lambda (item) (if (equal (gethash "idtype" item) "doi") (gethash "value" item))) ids))))

                                                          (decorated (consult-omni-dynamic--pubmed-format-candidate :source source :query query :url url :search-url search-url :title title :authors authors :date date :journal journal :doi doi)))
                                                       (propertize decorated
                                                                   :source source
                                                                   :url url
                                                                   :title title
                                                                   :search-url search-url
                                                                   :query query
                                                                   :journal journal
                                                                   :authors authors
                                                                   :date date
                                                                   :doi doi)))
                                                   uids)))
                                (when (and annotated-results (functionp callback))
                                  (funcall callback annotated-results)
                                    )
                                annotated-results)))))

#+end_src
***** main
#+begin_src emacs-lisp
(cl-defun consult-omni--pubmed-fetch-results (input &rest args &key callback &allow-other-keys)
  "Fetches results for INPUT from PubMed using Entrez Utilities service.
"
(let* ((esearch (consult-omni--pubmed-esearch-fetch-results input))
       (webenv (plist-get esearch :webenv))
       (qk (plist-get esearch :qk)))
  (consult-omni--pubmed-esummary-fetch-results input :callback callback :webenv webenv :qk qk)
))

#+end_src
**** define source
#+begin_src emacs-lisp

(consult-omni-define-source "PubMed"
                           :narrow-char ?p
                           :type 'dynamic
                           :require-match t
                           :category 'consult-omni-scholar
                           :face 'consult-omni-scholar-title-face
                           :request #'consult-omni--pubmed-fetch-results
                           :preview-key consult-omni-preview-key
                           :search-hist 'consult-omni--search-history
                           :select-hist 'consult-omni--selection-history
                           :enabled (lambda () (bound-and-true-p consult-omni-pubmed-api-key))
                           :group #'consult-omni--group-function
                           :sort t
                           :static 'both
                           :annotate nil
                           )
#+end_src
**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-pubmed' module

(provide 'consult-omni-pubmed)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-pubmed)
;;; consult-omni-pubmed.el ends here
#+end_src


*** Scopus
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-scopus.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-omni-scopus.el --- Consulting Scopus -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: ((emacs "28.1") (consult "1.4") (consult-omni "0.1"))
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:

;;; Code:

(require 'consult-omni)
#+end_src
**** variables
***** custom
#+begin_src emacs-lisp

(defcustom consult-omni-scopus-api-key nil
  "Key for Scopus API.

See URL `https://dev.elsevier.com/documentation/SCOPUSSearchAPI.wadl' for more info"
  :group 'consult-omni
  :type '(choice (const :tag "Scopus API Key" string)
                 (function :tag "Custom Function")))
#+end_src
***** other
#+begin_src emacs-lisp

(defvar consult-omni-scopus-search-url "https://www.scopus.com/record/display.uri?")

(defvar consult-omni-scopus-api-url "https://api.elsevier.com/content/search/scopus")

#+end_src
**** helper functions
***** format
#+begin_src emacs-lisp
(cl-defun consult-omni--scopus-format-candidate (&rest args &key source query url search-url title authors date journal doi face &allow-other-keys)
  "Returns a formatted string for candidates of `consult-omni-scopus'.

SOURCE is the name to use (e.g. “PubMed”)

QUERY is the query input from the user

URL is the url of  candidate

SEARCH-URL is the web search url
(e.g. https://www.scopus.com/record/display.uri?&eid=%s)

TITLE is the title of the result/paper (e.g. title of paper)

AUTHORS are authors of the result/paper

DATE is the publish date of the result/paper

JOURNAL is the journal that the result/paper is published in

DOI is doi of the result/paper

FACE is the face to apply to TITLE
"
  (let* ((frame-width-percent (floor (* (frame-width) 0.1)))
         (source (if (stringp source) (propertize source 'face 'consult-omni-source-type-face) nil))
         (date (if (stringp date) (propertize date 'face 'consult-omni-date-face) nil))
         (journal (if (stringp journal) (propertize journal 'face 'consult-omni-domain-face) nil))
         (authors (cond
                   ((and authors (listp authors))
                    (concat (first authors) ",..., " (car (last authors))))
                   ((stringp authors)
                    authors)
                   (t nil)
                   ))
         (authors (if (and authors (stringp authors)) (propertize authors 'face 'consult-omni-source-type-face)))
         (doi (if (stringp doi) (propertize doi 'face 'link) nil))
         (match-str (if (stringp query) (consult--split-escaped query) nil))
         (face (or (consult-omni--get-source-prop source :face) face 'consult-omni-default-face))
         (title-str (propertize title 'face face))
         (title-str (consult-omni--set-string-width title-str (* 5 frame-width-percent)))
         (str (concat title-str
                      (if journal (format "\t%s" journal))
                      (if date (format "\s\s%s" date))
                      (if authors (format "\s\s%s" authors))
                      (if source (concat "\t" source)))))
    (if consult-omni-highlight-matches
        (cond
         ((listp match-str)
          (mapcar (lambda (match) (setq str (consult-omni--highlight-match match str t))) match-str))
         ((stringp match-str)
          (setq str (consult-omni--highlight-match match-str str t)))))
    str))
#+end_src
***** callback
#+begin_src emacs-lisp
(defun consult-omni--scopus-callback (cand)
  "Callback function for `consult-omni-scopus'."
  (let* ((doi (get-text-property 0 :doi cand))
         (url (if doi (consult-omni--doi-to-url doi)
                (get-text-property 0 :url cand))))
         (funcall consult-omni-default-browse-function url)))
#+end_src
***** preview
#+begin_src emacs-lisp
(defun consult-omni--scopus-preview (cand)
   "Preview function for `consult-omni-scopus'."
  (let* ((doi (get-text-property 0 :doi cand))
         (url (if doi (consult-omni--doi-to-url doi)
                (get-text-property 0 :url cand))))
         (funcall consult-omni-default-preview-function url)))
#+end_src
**** items
#+begin_src emacs-lisp
(cl-defun consult-omni--scopus-fetch-results (input &rest args &key callback &allow-other-keys)
  "Retrieve search results from SCOPUS for INPUT.
"
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (seq-difference args (list :callback callback))))
               (opts (car-safe opts))
               (count (plist-get opts :count))
               (page (plist-get opts :page))
               (count (or (and count (integerp (read count)) (string-to-number count))
                          consult-omni-default-count))
               (page (or (and page (integerp (read page)) (string-to-number page))
                         consult-omni-default-page))
               (count (min (max count 1) 25))
               (page (* count page))
               (params `(("query" . ,(replace-regexp-in-string " " "+" query))
                         ("count" . ,(format "%s" count))
                         ("start" . ,(format "%s" page))
                         ("apiKey" . ,(consult-omni-expand-variable-function consult-omni-scopus-api-key))))
               (headers `(("Accept" . "application/json")
                          )))
    (consult-omni--fetch-url consult-omni-scopus-api-url consult-omni-http-retrieve-backend
                            :encoding 'utf-8
                            :params params
                            :headers headers
                            :parser #'consult-omni--json-parse-buffer
                            :callback
                            (lambda (attrs)
                              (when-let* ((raw-results (map-nested-elt attrs '("search-results" "entry")))
                                          (annotated-results
                                           (mapcar (lambda (item)
                                                     (let*
                                                         ((source "Scopus")
                                                          (title (gethash "dc:title" item))
                                                          (journal (gethash "prism:publicationName" item))
                                                          (volume (gethash "prism:volume" item))
                                                          (pages (gethash "prism:pageRange" item))
                                                          (authors (gethash "dc:creator" item))
                                                          (authors (cond
                                                                    ((stringp authors) (list authors))
                                                                    (t authors)))
                                                          (date (gethash "prism:coverDate" item))
                                                          (eid (gethash "eid" item))
                                                          (doi (gethash "prism:doi" item))
                                                          (url (concat consult-omni-scopus-search-url "&eid=" eid "&origin=inward"))

                                                          (search-url (concat consult-omni-scopus-search-url "&eid=" eid "&origin=inward"))

                                                          (decorated (consult-omni--scopus-format-candidate :source source :query query :url url :search-url search-url :title title :authors authors :date date :journal journal :doi doi)))
                                                       (propertize decorated
                                                                   :source source
                                                                   :url url
                                                                   :title title
                                                                   :search-url search-url
                                                                   :query query
                                                                   :journal journal
                                                                   :volume volume
                                                                   :pages pages
                                                                   :authors authors
                                                                   :date date
                                                                   :doi doi
                                                                   :eid eid)))

                                                   raw-results)))
                                (funcall callback annotated-results))))))
#+end_src
**** define source
#+begin_src emacs-lisp

(consult-omni-define-source "Scopus"
                           :narrow-char ?s
                           :type 'dynamic
                           :require-match t
                           :category 'consult-omni-scholar
                           :face 'consult-omni-scholar-title-face
                           :request #'consult-omni--scopus-fetch-results
                           :preview-key consult-omni-preview-key
                           :on-preview #'consult-omni--scopus-preview
                           :on-return #'identity
                           :on-callback #'consult-omni--scopus-callback
                           :search-hist 'consult-omni--search-history
                           :select-hist 'consult-omni--selection-history
                           :enabled (lambda () (bound-and-true-p consult-omni-scopus-api-key))
                           :group #'consult-omni--group-function
                           :sort t
                           :static 'both
                           :annotate nil
                           )

#+end_src

**** provide and footer

#+begin_src emacs-lisp
;;; provide `consult-omni-scopus' module

(provide 'consult-omni-scopus)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-scopus)
;;; consult-omni-scopus.el ends here
#+end_src
*** Stackoverflow
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-stackoverflow.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-omni-stackoverflow.el --- Consulting StackOverflow -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: ((emacs "28.1") (consult "1.4") (consult-omni "0.1"))
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:

;;; Code:

(require 'consult-omni)
#+end_src
**** variables
***** custom
#+begin_src emacs-lisp
(defcustom consult-omni-stackexchange-api-key nil
  "Key for Stack Exchange API.

See URL `https://api.stackexchange.com/', and URL `https://stackapps.com/' for more info"
  :group 'consult-omni
  :type '(choice (const :tag "API Key" string)
                 (function :tag "Custom Function")))
#+end_src
***** other
#+begin_src emacs-lisp
(defvar consult-omni-stackoverflow-search-url "https://stackoverflow.com/search")
(defvar consult-omni-stackoverflow-api-url "https://api.stackexchange.com/2.3/search/advanced")
(defvar consult-omni-stackoverflow-answered-mark "+")
(defvar consult-omni-stackoverflow-unanswered-mark "x")
#+end_src
**** helper functions
***** format
#+begin_src emacs-lisp
(cl-defun consult-omni--stackoverflow-format-candidate (&rest args &key source query url search-url title snippet date answered score face &allow-other-keys)
  "Returns a formatted string for Wikipedia's searches.

SOURCE is the name string of the source for candidate

QUERY is the query string used for searching

URL is a string pointing to url of the candidate

SEARCH-URL is a string pointing to the url for
the search results of QUERY on the SOURCE website

TITLE is the title of the candidate

SNIPPET is a string containing a snippet/description of candidate
"
  (let* ((frame-width-percent (floor (* (frame-width) 0.1)))
         (source (and (stringp source) (propertize source 'face 'consult-omni-source-type-face)))
         (date (and (stringp date) (propertize date 'face 'consult-omni-date-face)))
         (answered (if answered (propertize consult-omni-stackoverflow-answered-mark 'face 'consult-omni-domain-face)
                     (propertize consult-omni-stackoverflow-unanswered-mark 'face 'error)))
         (score (and score (propertize (format "%s" score) 'face 'consult-omni-path-face)))
         (match-str (and (stringp query) (consult--split-escaped query) nil))
         (face (or (consult-omni--get-source-prop source :face) face 'consult-omni-default-face))
         (title-str (propertize title 'face face))
         (title-str (consult-omni--set-string-width title-str (* 7 frame-width-percent)))
         (str (concat title-str
                      (when date (concat "\s" date))
                      (when answered (concat "\s" answered))
                      (when score (concat "\s" score))
                      (when source (concat "\t" source)))))
    (if consult-omni-highlight-matches
        (cond
         ((listp match-str)
          (mapcar (lambda (match) (setq str (consult-omni--highlight-match match str t))) match-str))
         ((stringp match-str)
          (setq str (consult-omni--highlight-match match-str str t)))))
    str))
#+end_src
**** items
#+begin_src emacs-lisp
(cl-defun consult-omni--stackoverflow-fetch-results (input &rest args &key callback &allow-other-keys)
  "Fetch search results for INPUT from StackOverflow.
See URL `https://api.stackexchange.com/' for more info.
"
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (seq-difference args (list :callback callback))))
               (opts (car-safe opts))
               (count (plist-get opts :count))
               (page (plist-get opts :page))
               (order (plist-get opts :order))
               (sort (plist-get opts :sort))
               (count (or (and count (integerp (read count)) (string-to-number count))
                          consult-omni-default-count))
               (page (or (and page (integerp (read page)) (string-to-number page))
                         consult-omni-default-page))
               (count (min count 25))
               (page (max page 1))
               (order (if (and order (member (format "%s" order) '("desc" "asc"))) (format "%s" order)))
               (sort (if (and sort (member (format "%s" sort) '("activity" "votes" "creation" "relevance"))) (format "%s" sort)))
               (params `(("order" . ,(or order "desc"))
                         ("sort" . ,(or sort "relevance"))
                         ("site" . "stackoverflow")
                         ("q" . ,(replace-regexp-in-string " " "+" query))
                         ("pagesize" . ,(format "%s" count))
                         ("page" . ,(format "%s" page))
                         ("key" . ,(consult-omni-expand-variable-function consult-omni-stackexchange-api-key))))
               (headers '(("Accept" . "application/json"))))
    (consult-omni--fetch-url consult-omni-stackoverflow-api-url consult-omni-http-retrieve-backend
                            :encoding 'utf-8
                            :params params
                            :headers headers
                            :parser #'consult-omni--json-parse-buffer
                            :callback
                            (lambda (attrs)
                              (let* ((raw-results (gethash "items" attrs))
                                     (annotated-results
                                      (mapcar (lambda (item)
                                                (let*
                                                    ((source "StackOverflow")
                                                     (url (format "%s" (gethash "link" item)))
                                                     (title (format "%s" (gethash "title" item)))
                                                     (date (gethash "last_edit_date" item))
                                                     (date (format-time-string "%Y-%m-%d" (seconds-to-time date)))
                                                     (answered (gethash "is_answered" item))
                                                     (score (gethash "score" item))
                                                     (search-url (concat consult-omni-stackoverflow-search-url "?q=" input))
                                                     (decorated (consult-omni--stackoverflow-format-candidate :source source :query query :url url :search-url search-url :title title :date date :answered answered :score score)))
                                                  (propertize decorated
                                                              :source source
                                                              :title title
                                                              :url url
                                                              :search-url search-url
                                                              :query query
                                                              :date date
                                                              :answered answered
                                                              :score score
                                                              )))

                                              raw-results)))
                                (when (and annotated-results (functionp callback))
                                  (funcall callback annotated-results))
                                annotated-results)))))
#+end_src
**** define source
#+begin_src emacs-lisp

(consult-omni-define-source "StackOverflow"
                           :narrow-char ?s
                           :type 'dynamic
                           :require-match t
                           :face 'consult-omni-engine-title-face
                           :request #'consult-omni--stackoverflow-fetch-results
                           :preview-key consult-omni-preview-key
                           :search-hist 'consult-omni--search-history
                           :select-hist 'consult-omni--selection-history
                           :enabled (lambda () (bound-and-true-p consult-omni-stackexchange-api-key))
                           :group #'consult-omni--group-function
                           :sort t
                           :static 'both
                           :annotate nil
                           )
#+end_src

**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-stackoverflow' module

(provide 'consult-omni-stackoverflow)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-stackoverflow)
;;; consult-omni-stackoverflow.el ends here
#+end_src


*** Wikipedia
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-wikipedia.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-omni-wikipedia.el --- Consulting Wikipedia -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: ((emacs "28.1") (consult "1.4") (consult-omni "0.1"))
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:

;;; Code:

(require 'consult-omni)
#+end_src
**** variables
***** other
#+begin_src emacs-lisp
(defvar consult-omni-wikipedia-search-url "https://www.wikipedia.org/search-redirect.php")
(defvar consult-omni-wikipedia-url "https://wikipedia.org/")
(defvar consult-omni-wikipedia-api-url "https://wikipedia.org/w/api.php")
#+end_src
**** helper functions
***** format
#+begin_src emacs-lisp
(cl-defun consult-omni--wikipedia-format-candidate (&rest args &key source query url search-url title snippet date face &allow-other-keys)
  "Returns a formatted string for Wikipedia's searches.

SOURCE is the name string of the source for candidate

QUERY is the query string used for searching

URL is a string pointing to url of the candidate

SEARCH-URL is the web search url e.g.:
https://www.wikipedia.org/search-redirect.php?search=query

TITLE is the title of the candidate

SNIPPET is a string containing a snippet/description of candidate

DATE is the date the article was last updated

FACE is the face to apply to TITLE
"
  (let* ((frame-width-percent (floor (* (frame-width) 0.1)))
         (source (and (stringp source) (propertize source 'face 'consult-omni-source-type-face)))
         (date (and (stringp date) (propertize date 'face 'consult-omni-date-face)))
         (match-str (and (stringp query) (consult--split-escaped query) nil))
         (face (or (consult-omni--get-source-prop source :face) face 'consult-omni-default-face))
         (title-str (propertize title 'face face))
         (title-str (consult-omni--set-string-width title-str (* 3 frame-width-percent)))
         (snippet (and (stringp snippet) (consult-omni--set-string-width (string-trim snippet) (* 6 frame-width-percent))))
         (snippet (and (stringp snippet) (propertize snippet 'face 'consult-omni-snippet-face)))
         (str (concat title-str
                      (when date (concat "\s" date))
                      (when snippet (concat "\s\s" snippet))
                      (when source (concat "\t" source)))))
    (if consult-omni-highlight-matches
        (cond
         ((listp match-str)
          (mapcar (lambda (match) (setq str (consult-omni--highlight-match match str t))) match-str))
         ((stringp match-str)
          (setq str (consult-omni--highlight-match match-str str t)))))
    str))
#+end_src
**** items
#+begin_src emacs-lisp
(cl-defun consult-omni--wikipedia-fetch-results (input &rest args &key callback &allow-other-keys)
  "Fetches search results from Wikipedia for INPUT.
"

  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (seq-difference args (list :callback callback))))
               (opts (car-safe opts))
               (count (plist-get opts :count))
               (page (plist-get opts :page))
               (count (or (and count (integerp (read count)) (string-to-number count))
                             consult-omni-default-count))
               (page (or (and page (integerp (read page)) (string-to-number page))
                         consult-omni-default-page))
               (count (max count 1))
               (params `(("action" . "query")
                 ("format" . "json")
                 ("list" . "search")
                 ("formatversion" . "2")
                 ("prop" . "info")
                 ("inprop" . "url")
                 ("srwhat" . "text")
                 ("srsearch" . ,(url-hexify-string query))
                 ("srlimit" . ,(format "%s" count))
                 ("sroffset" . ,(format "%s" page))))
               (headers '(("User-Agent" . "Emacs:consult-omni/0.1 (https://github.com/armindarvish/consult-omni);"))))
    (consult-omni--fetch-url consult-omni-wikipedia-api-url consult-omni-http-retrieve-backend
      :encoding 'utf-8
      :params params
      :headers headers
      :parser #'consult-omni--json-parse-buffer
      :callback
      (lambda (attrs)
        (when-let* ((raw-results (map-nested-elt attrs '("query" "search")))
                    (annotated-results
                     (mapcar (lambda (item)
                               (let*
                                   ((source "Wikipedia")
                                    (title (format "%s" (gethash "title" item)))
                                    (url (concat consult-omni-wikipedia-url "wiki/" (string-replace " " "_" title)))
                                    (date (gethash "timestamp" item))
                                    (date (format-time-string "%Y-%m-%d" (date-to-time date)))
                                    (snippet (replace-regexp-in-string "<span.*?>\\|</span>\\|&quot;" "" (format "%s" (gethash "snippet" item))))
                                    (search-url (concat  consult-omni-wikipedia-search-url "?" "search=" query))
                                    (decorated (consult-omni--wikipedia-format-candidate :source source :query query :url url :search-url search-url :title title :snippet snippet :date date)))
                                 (propertize decorated
                                             :source source
                                             :title title
                                             :url url
                                             :search-url search-url
                                             :query query
                                             :date date)))

                             raw-results)))
          (funcall callback annotated-results)
          annotated-results)))))

#+end_src
**** define source
#+begin_src emacs-lisp

(consult-omni-define-source "Wikipedia"
                           :narrow-char ?w
                           :type 'dynamic
                           :require-match t
                           :face 'consult-omni-engine-title-face
                           :request #'consult-omni--wikipedia-fetch-results
                           :preview-key consult-omni-preview-key
                           :search-hist 'consult-omni--search-history
                           :select-hist 'consult-omni--selection-history
                           :enabled (lambda () (boundp  'consult-omni-wikipedia-api-url))
                           :group #'consult-omni--group-function
                           :sort t
                           :type 'dynamic
                           :static 'both
                            )
#+end_src

**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-wikipedia' module

(provide 'consult-omni-wikipedia)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-wikipedia)
;;; consult-omni-wikipedia.el ends here
#+end_src
*** YouTube
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-youtube.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-omni-youtube.el --- Consulting YouTube -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: ((emacs "28.1") (consult "1.4") (consult-omni "0.1"))
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:

;;; Code:

(require 'consult-omni)
#+end_src
**** variables
***** custom
#+begin_src emacs-lisp
(defcustom consult-omni-youtube-search-key nil
  "Key for “YouTube Data API”

See URL `https://developers.google.com/youtube/v3/getting-started'
for details"
  :group 'consult-omni
  :type '(choice (const :tag "API Key" string)
                 (function :tag "Custom Function")))

(defcustom consult-omni-youtube-search-command #'consult-omni--youtube-fetch-results-details
  "Command to use to get results from “YouTube Data API”
"
  :group 'consult-omni
  :type '(choice (function :tag "(Default) Detailed Results with stats" #'consult-omni--youtube-fetch-results-details)
                 (function :tag "Simple Results without stats"  #'consult-omni--youtube-fetch-results-simple)
                 (function :tag "Custom Function")))
#+end_src
***** other
#+begin_src emacs-lisp
(defvar consult-omni-youtube-base-url "https://www.youtube.com/")
(defvar consult-omni-youtube-watch-url "https://www.youtube.com/watch")
(defvar consult-omni-youtube-channel-url "https://www.youtube.com/channel/")
(defvar consult-omni-youtube-search-results-url "https://www.youtube.com/results")
(defvar consult-omni-youtube-search-api-url "https://www.googleapis.com/youtube/v3/search")
(defvar consult-omni-youtube-videos-api-url "https://www.googleapis.com/youtube/v3/videos")
(defvar consult-omni-youtube-playlists-api-url "https://www.googleapis.com/youtube/v3/playlists")
(defvar consult-omni-youtube-channels-api-url "https://www.googleapis.com/youtube/v3/channels")
#+end_src
**** helper functions
***** format
#+begin_src emacs-lisp
(cl-defun consult-omni--youtube-format-candidate (&rest args &key source type query title snippet channeltitle date length subcount videocount viewcount face &allow-other-keys)
"Formats a candidate for `consult-omni-youtube' commands.

SOURCE is the name to use (e.g. “YouTube”)

TYPE is the type of candidate (e.g. video, channel, playlist)

QUERY is the query input from the user

TITLE is the title of the video

SNIPPET is a string containing a snippet/description of the video

CHANNELTITLE is the name of the channel for the video

DATE is the publish date of the video

LENGTH is the duration of a  video in seconds

SUBCOUNT is the subscriber count fpr a channel

VIDEOCOUNT is the number of videos in a playlist

VIEWCOUNT is the number of times a video is viewed

FACE is the face to apply to TITLE
"
  (let* ((frame-width-percent (floor (* (frame-width) 0.1)))
         (source (propertize source 'face 'consult-omni-source-type-face))
         (match-str (if (stringp query) (consult--split-escaped query) nil))
         (date (and (stringp date) (propertize date 'face 'consult-omni-date-face)))
         (channeltitle (and (stringp channeltitle) (propertize channeltitle 'face 'consult-omni-path-face)))
         (channeltitle (consult-omni--set-string-width channeltitle (* 2 frame-width-percent)))
         (snippet (if (stringp snippet) (consult-omni--set-string-width (replace-regexp-in-string "\n" "  " snippet) (* 2 frame-width-percent))))
         (snippet (and snippet (stringp snippet) (propertize snippet 'face 'consult-omni-snippet-face)))
         (videocount-str (and videocount (consult-omni--numbers-human-readable (or videocount 0) "videos")))
         (viewcount-str (and viewcount (consult-omni--numbers-human-readable (or viewcount 0) "views")))
         (subcount-str (and subcount (consult-omni--numbers-human-readable (or subcount 0) "subs")))
         (stats (and type
                    (stringp type)
                    (propertize
                     (consult-omni--set-string-width (pcase type
                      ("video" (format "%s" (or viewcount-str "0 views")))
                      ("playlist" (format "%s" (or videocount-str "0 videos")))
                      ("channel" (format "%s" (or subcount-str "0 subscriptions")))
                      (_ "")) 10)
                     'face 'consult-omni-domain-face)))
         (length (or
                  (and (equal type "playlist") "[PLAYLIST]")
                  (and (equal type "channel") "(CHANNEL)")
                  (and (numberp length) (seconds-to-string length))))
         (length (and (stringp length) (consult-omni--set-string-width (propertize length 'face 'consult-omni-comment-face) 10)))

         (face (or (consult-omni--get-source-prop source :face) face 'consult-omni-default-face))
         (title-str (propertize title 'face face))
         (title-str (consult-omni--set-string-width title-str (* 5 frame-width-percent)))
         (str (concat title-str
                      (when date (concat "\s" date))
                      (when channeltitle (concat " " channeltitle))
                      (when length (concat "\s" length))
                      (unless (string-empty-p stats) (concat "\s" stats))
                      (when snippet (concat "\s\s" snippet))
                      (concat "\t" source)))
         )
    (if consult-omni-highlight-matches
        (cond
         ((listp match-str)
          (mapcar (lambda (match) (setq str (consult-omni--highlight-match match str t))) match-str))
         ((stringp match-str)
          (setq str (consult-omni--highlight-match match-str str t)))))
    str))
#+end_src
**** items
***** youtube search simple
#+begin_src emacs-lisp
(cl-defun consult-omni--youtube-fetch-results-simple (input &rest args &key callback &allow-other-keys)
  "Fetches search results for INPUT from “YouTube Data API” service.

This is a simpler version that does not show details
such as viw counts and duration, ... of videos/playlists, etc.
"
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (seq-difference args (list :callback callback))))
               (opts (car-safe opts))
               (count (plist-get opts :count))
               (page (plist-get opts :page))
               (def (plist-get opts :def))
               (type (plist-get opts :type))
               (vidtype (plist-get opts :vidtype))
               (order (or (plist-get opts :order) (plist-get opts :sort)))
               (count (or (and count (integerp (read count)) (string-to-number count))
                          consult-omni-default-count))
               (page (or (and page (integerp (read page)) (string-to-number page))
                         consult-omni-default-count))
               (def (if (and def (member (format "%s" def) '("any" "standard" "high"))) (format "%s" def) "any"))
               (type (if (and type (member (format "%s" type) '("channel" "playlist" "video"))) (format "%s" type) "video"))
               (vidtype (if (and vidtype (member (format "%s" vidtype) '("any" "episode" "movie"))) (format "%s" vidtype) "any"))
               (count (min count 10))
               (page (+ (* page count) 1))
               (order  (if (and order (member (format "%s" order) '("date" "rating" "relevance" "title" "videoCount" "viewCount"))) (format "%s" order) "relevance"))
               (params `(("q" . ,(replace-regexp-in-string " " "+" query))
                         ("part" . "snippet")
                         ("order" . ,order)
                         ("type" . ,type)
                         ("maxResults" . ,(format "%s" count))
                         ("videoDefinition" . ,def)
                         ("videoType" . ,vidtype)
                         ("key" . ,(consult-omni-expand-variable-function consult-omni-youtube-search-key))
                         ))
               (headers `(("Accept" . "application/json")
                          ("Accept-Encoding" . "gzip")
                          ("User-Agent" . "consult-omni (gzip)")
                          ("X-Goog-Api-Key" . ,(consult-omni-expand-variable-function consult-omni-youtube-search-key)))))
    (consult-omni--fetch-url consult-omni-youtube-search-api-url consult-omni-http-retrieve-backend
                             :encoding 'utf-8
                             :params params
                             :headers headers
                             :parser #'consult-omni--json-parse-buffer
                             :callback
                             (lambda (attrs)
                               (let* ((raw-results (gethash "items" attrs))
                                      (annotated-results
                                       (mapcar (lambda (item)
                                                 (let*
                                                     ((source "YouTube")
                                                      (videoid (gethash "videoId" (gethash "id" item)))
                                                      (snippet (gethash "snippet" item))
                                                      (channeltitle (gethash "channelTitle" snippet))
                                                      (channelid (gethash "channelId" snippet))
                                                      (title (gethash "title" snippet))
                                                      (date (gethash "publishedAt" snippet))
                                                      (date (format-time-string "%Y-%m-%d" (date-to-time date)))
                                                      (url (cond
                                                            (videoid (consult-omni--make-url-string consult-omni-youtube-watch-url `(("v" . ,videoid))))
                                                            (channelid (concat consult-omni-youtube-channel-url channelid))))
                                                      (search-url (consult-omni--make-url-string consult-omni-youtube-search-results-url `(("search_query" . ,query))))
                                                      (description (gethash "description" snippet))

                                                      (decorated (consult-omni--youtube-format-candidate :source source :query query :title title :snippet description :channeltitle channeltitle :date date)))
                                                   (propertize decorated
                                                               :source source
                                                               :title title
                                                               :url url
                                                               :search-url search-url
                                                               :query query
                                                               :snippet description
                                                               :videoid videoid
                                                               :channeltitle channeltitle
                                                               :channelid channelid)))

                                               raw-results)))
                                 (when (and annotated-results (functionp callback))
                                   (funcall callback annotated-results))
                                 annotated-results)))))
#+end_src
***** youtube search details
****** youtube videos
#+begin_src emacs-lisp
(cl-defun consult-omni--youtube-fetch-video-details (videoids &rest args &key callback query &allow-other-keys)
  "Fetches details with VIDEOIDS from “YouTube Data API” service.
"
  (pcase-let* ((params `(("part" . "snippet,statistics,contentDetails")
                         ("key" . ,(consult-omni-expand-variable-function consult-omni-youtube-search-key))
                         ("id" . ,(string-join videoids ","))
                         ))
               (headers `(("Accept" . "application/json")
                          ("Accept-Encoding" . "gzip")
                          ("User-Agent" . "consult-omni (gzip)")
                          ("X-Goog-Api-Key" . ,(consult-omni-expand-variable-function consult-omni-youtube-search-key)))))
    (consult-omni--fetch-url consult-omni-youtube-videos-api-url consult-omni-http-retrieve-backend
                            :encoding 'utf-8
                            :params params
                            :headers headers
                            :parser #'consult-omni--json-parse-buffer
                            :callback
                            (lambda (attrs)
                              (let* ((raw-results (gethash "items" attrs))
                                     (annotated-results
                                      (mapcar (lambda (item)
                                                (let*
                                                    ((source "YouTube")
                                                     (videoid (gethash "id" item))
                                                     (snippet (gethash "snippet" item))
                                                     (contentdetails (gethash "contentDetails" item))
                                                     (statistics (gethash "statistics" item))
                                                     (channeltitle (gethash "channelTitle" snippet))
                                                     (channelid (gethash "channelId" snippet))
                                                     (title (gethash "title" snippet))
                                                     (date (gethash "publishedAt" snippet))
                                                     (date (format-time-string "%Y-%m-%d" (date-to-time date)))
                                                     (url (consult-omni--make-url-string consult-omni-youtube-watch-url `(("v" . ,videoid))))
                                                     (search-url (consult-omni--make-url-string consult-omni-youtube-search-results-url `(("search_query" . ,query))))
                                                     (description (gethash "description" snippet))
                                                     (duration (gethash "duration" contentdetails))
                                                     (duration (if duration (iso8601-parse-duration duration)))
                                                     (duration (if duration (+ (* (caddr duration) 2600) (* (cadr duration) 60) (car duration))))
                                                     (viewcount (string-to-number (gethash "viewCount" statistics)))
                                                     (decorated (consult-omni--youtube-format-candidate :source source :type "video" :query query :title title :snippet description :channeltitle channeltitle :date date :length duration :viewcount viewcount)))
                                                (propertize decorated
                                                            :source source
                                                            :title title
                                                            :url url
                                                            :search-url search-url
                                                            :query query
                                                            :snippet description
                                                            :id videoid
                                                            :channeltitle channeltitle
                                                            :channelid channelid)))

                                      raw-results)))
                               (when (and annotated-results (functionp callback))
                                (funcall callback annotated-results))
                              annotated-results)))))

#+end_src

****** youtube playlists
#+begin_src emacs-lisp
(cl-defun consult-omni--youtube-fetch-playlist-details (playlistids &rest args &key callback query candidates &allow-other-keys)
  "Fetches details with PLAYLISTIDS from “YouTube Data API” service.

"
  (pcase-let* ((params `(("part" . "snippet,contentDetails")
                         ("key" . ,(consult-omni-expand-variable-function consult-omni-youtube-search-key))
                         ("id" . ,(string-join playlistids ","))
                         ))
               (headers `(("Accept" . "application/json")
                          ("Accept-Encoding" . "gzip")
                          ("User-Agent" . "consult-omni (gzip)")
                          ("X-Goog-Api-Key" . ,(consult-omni-expand-variable-function consult-omni-youtube-search-key)))))
    (consult-omni--fetch-url consult-omni-youtube-playlists-api-url consult-omni-http-retrieve-backend
                            :encoding 'utf-8
                            :params params
                            :headers headers
                            :parser #'consult-omni--json-parse-buffer
                            :callback
                            (lambda (attrs)
                              (let* ((raw-results (gethash "items" attrs))
                                     (annotated-results
                                      (mapcar (lambda (item)
                                                (let*
                                                    ((source "YouTube")
                                                     (playlistid (gethash "id" item))
                                                     (snippet (gethash "snippet" item))
                                                     (contentdetails (gethash "contentDetails" item))
                                                     (videocount (gethash "itemCount" contentdetails))
                                                     (channeltitle (gethash "channelTitle" snippet))
                                                     (channelid (gethash "channelId" snippet))
                                                     (title (gethash "title" snippet))
                                                     (date (gethash "publishedAt" snippet))
                                                     (date (format-time-string "%Y-%m-%d" (date-to-time date)))
                                                     (url (consult-omni--make-url-string consult-omni-youtube-watch-url `(("list" . ,playlistid))))
                                                     (search-url (consult-omni--make-url-string consult-omni-youtube-search-results-url `(("search_query" . ,query))))
                                                     (description (gethash "description" snippet))
                                                     (decorated (consult-omni--youtube-format-candidate :source source :type "playlist" :query query :title title :snippet description :channeltitle channeltitle :date date :videocount videocount)))
                                                (propertize decorated
                                                            :source source
                                                            :title title
                                                            :url url
                                                            :search-url search-url
                                                            :query query
                                                            :snippet description
                                                            :id playlistid
                                                            :channeltitle channeltitle
                                                            :channelid channelid)))

                                      raw-results)))
                              (when (and annotated-results (functionp callback))
                                 (funcall callback annotated-results))
                              annotated-results)))))
#+end_src


****** youtube channels
#+begin_src emacs-lisp
(cl-defun consult-omni--youtube-fetch-channel-details (channelids &rest args &key callback query candidates &allow-other-keys)
  "Fetches  details with CHANNELIDS from “YouTube Data API” service.
"
  (pcase-let* ((params `(("part" . "snippet,statistics")
                         ("key" . ,(consult-omni-expand-variable-function consult-omni-youtube-search-key))
                         ("id" . ,(string-join channelids ","))
                         ))
               (headers `(("Accept" . "application/json")
                          ("Accept-Encoding" . "gzip")
                          ("User-Agent" . "consult-omni (gzip)")
                          ("X-Goog-Api-Key" . ,(consult-omni-expand-variable-function consult-omni-youtube-search-key)))))
    (consult-omni--fetch-url consult-omni-youtube-channels-api-url consult-omni-http-retrieve-backend
                            :encoding 'utf-8
                            :params params
                            :headers headers
                            :parser #'consult-omni--json-parse-buffer
                            :callback
                            (lambda (attrs)
                              (let* ((raw-results (gethash "items" attrs))
                                     (annotated-results
                                      (mapcar (lambda (item)
                                                (let*
                                                    ((source "YouTube")
                                                     (channelid (gethash "id" item))
                                                     (snippet (gethash "snippet" item))
                                                     (statistics (gethash "statistics" item))
                                                     (title (gethash "title" snippet))
                                                     (customurl (gethash "customUrl" snippet))
                                                     (date (gethash "publishedAt" snippet))
                                                     (date (format-time-string "%Y-%m-%d" (date-to-time date)))
                                                     (subcount (gethash "subscriberCount" statistics))
                                                     (url (if customurl
                                                              (concat consult-omni-youtube-base-url customurl)
                                                            (concat consult-omni-youtube-channel-url channelid)))
                                                     (search-url (consult-omni--make-url-string consult-omni-youtube-search-results-url `(("search_query" . ,query))))
                                                     (description (gethash "description" snippet))
                                                     (decorated (consult-omni--youtube-format-candidate :source source :type "channel" :query query :title title :snippet description :channeltitle title :date date :subcount subcount)))
                                                (propertize decorated
                                                            :source source
                                                            :title title
                                                            :url url
                                                            :search-url search-url
                                                            :query query
                                                            :snippet description
                                                            :id channelid
                                                            :channeltitle title
                                                            :channelid channelid)))

                                      raw-results)))
                              (when (and annotated-results (functionp callback))
                                  (funcall callback annotated-results))
                              annotated-results)))))
#+end_src


****** youtube search with details
#+begin_src emacs-lisp
(cl-defun consult-omni--youtube-fetch-results-details (input &rest args &key callback &allow-other-keys)
  "Fetches search results for INPUT from “YouTube Data API” service.

This is a version with  statistics (e.g. view counts)
 and more details on videos, playlsits, etc.
"
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (seq-difference args (list :callback callback))))
               (opts (car-safe opts))
               (videos (make-vector 1 (list)))
               (playlists (make-vector 1 (list)))
               (count (plist-get opts :count))
               (page (plist-get opts :page))
               (def (plist-get opts :def))
               (search-type (plist-get opts :type))
               (vidtype (plist-get opts :vidtype))
               (order (or (plist-get opts :order) (plist-get opts :sort)))
               (count (or (and count (integerp (read count)) (string-to-number count))
                          consult-omni-default-count))
               (page (or (and page (integerp (read page)) (string-to-number page))
                         consult-omni-default-count))
               (def (if (and def (member (format "%s" def) '("any" "standard" "high"))) (format "%s" def)))
               (vidtype (if (and vidtype (member (format "%s" vidtype) '("any" "episode" "movie"))) (format "%s" vidtype)))
               (search-type (cond
                             ((or def vidtype) "video")
                             ((and search-type (member (format "%s" search-type) '("channel" "playlist" "video"))) (format "%s" search-type))))
               (count (min count 100))
               (page (+ (* page count) 1))
               (order  (if (and order (member (format "%s" order) '("date" "rating" "relevance" "title" "videoCount" "viewCount"))) (format "%s" order) "relevance"))
               (params (delq nil `(("q" . ,(replace-regexp-in-string " " "+" query))
                                   ("part" . "snippet")
                                   ("order" . ,order)
                                   ("maxResults" . ,(format "%s" count))
                                   ,(when search-type `("type" . ,(format "%s" search-type)))
                                   ,(when def `("videoDefinition" . ,def))
                                   ,(when vidtype `("videoType" . ,vidtype))
                                   ("key" . ,(consult-omni-expand-variable-function consult-omni-youtube-search-key))
                                   )))
               (headers `(("Accept" . "application/json")
                          ("Accept-Encoding" . "gzip")
                          ("User-Agent" . "consult-omni (gzip)")
                          ("X-Goog-Api-Key" . ,(consult-omni-expand-variable-function consult-omni-youtube-search-key)))))
    (consult-omni--fetch-url consult-omni-youtube-search-api-url consult-omni-http-retrieve-backend
                             :encoding 'utf-8
                             :params params
                             :headers headers
                             :parser #'consult-omni--json-parse-buffer
                             :callback
                             (lambda (attrs)
                               (let* ((raw-results (gethash "items" attrs))
                                      (videoids (list))
                                      (playlistids (list))
                                      (channelids (list)))
                                 (mapcar (lambda (item)
                                           (let* ((kind (gethash "kind" (gethash "id" item)))
                                                  (type (string-trim-left kind "youtube#")))
                                             (pcase type
                                               ("video"
                                                (push (gethash "videoId" (gethash "id" item)) videoids))
                                               ("playlist"
                                                (push (gethash "playlistId" (gethash "id" item)) playlistids))
                                               ("channel"
                                                (push (gethash "channelId" (gethash "id" item)) channelids)))
                                             )) raw-results)

                                 (when videoids
                                   (consult-omni--youtube-fetch-video-details videoids :callback callback :query query))

                                 (when playlistids
                                   (consult-omni--youtube-fetch-playlist-details playlistids :callback callback :query query))

                                 (when channelids
                                   (consult-omni--youtube-fetch-channel-details channelids :callback callback :query query))
                                 )))))
#+end_src

**** define source
#+begin_src emacs-lisp
(consult-omni-define-source "YouTube"
                           :narrow-char ?y
                           :type 'dynamic
                           :require-match t
                           :category 'consult-omni-video
                           :face 'consult-omni-engine-title-face
                           :request consult-omni-youtube-search-command
                           :preview-key consult-omni-preview-key
                           :search-hist 'consult-omni--search-history
                           :select-hist 'consult-omni--selection-history
                           :enabled (lambda () (bound-and-true-p consult-omni-youtube-search-key))
                           :group #'consult-omni--group-function
                           :sort t
                           :static 'both
                           :annotate nil
                           )
#+end_src

**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-youtube' module

(provide 'consult-omni-youtube)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-youtube)
;;; consult-omni-youtube.el ends here
#+end_src
